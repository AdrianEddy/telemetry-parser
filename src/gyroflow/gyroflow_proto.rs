// This file is @generated by prost-build.
/// Main entry point of the data
/// The first message will contain the Header with CameraMetadata and ClipMetadata
/// All subsequent per-frame samples will contain the FrameMetadata, without Header
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Main {
    /// Magic string useful for format detection in binary data. Always "GyroflowProtobuf"
    #[prost(string, tag = "1")]
    pub magic_string: ::prost::alloc::string::String,
    /// Version of the protocol, currently 1.
    #[prost(uint32, tag = "2")]
    pub protocol_version: u32,
    #[prost(message, optional, tag = "3")]
    pub header: ::core::option::Option<Header>,
    #[prost(message, optional, tag = "4")]
    pub frame: ::core::option::Option<FrameMetadata>,
}
/// One-time metadata containing information about the camera, lens and this particular video clip
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    #[prost(message, optional, tag = "1")]
    pub camera: ::core::option::Option<header::CameraMetadata>,
    #[prost(message, optional, tag = "2")]
    pub clip: ::core::option::Option<header::ClipMetadata>,
}
/// Nested message and enum types in `Header`.
pub mod header {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CameraMetadata {
        /// Camera manufacturer
        #[prost(string, tag = "1")]
        pub camera_brand: ::prost::alloc::string::String,
        /// Camera model
        #[prost(string, tag = "2")]
        pub camera_model: ::prost::alloc::string::String,
        /// Camera serial number
        #[prost(string, optional, tag = "3")]
        pub camera_serial_number: ::core::option::Option<::prost::alloc::string::String>,
        /// Camera firmware version
        #[prost(string, optional, tag = "4")]
        pub firmware_version: ::core::option::Option<::prost::alloc::string::String>,
        /// Lens manufacturer
        #[prost(string, tag = "5")]
        pub lens_brand: ::prost::alloc::string::String,
        /// Lens model
        #[prost(string, tag = "6")]
        pub lens_model: ::prost::alloc::string::String,
        /// Sensor pixel pitch in nanometers
        #[prost(uint32, tag = "7")]
        pub pixel_pitch_nm: u32,
        /// Full sensor width in pixels
        #[prost(uint32, tag = "8")]
        pub sensor_pixel_width: u32,
        /// Full sensor height in pixels
        #[prost(uint32, tag = "9")]
        pub sensor_pixel_height: u32,
        /// Crop factor in relation to full frame sensor size. e.g. 1.6x for APS-C
        #[prost(float, optional, tag = "10")]
        pub crop_factor: ::core::option::Option<f32>,
        /// The Gyroflow lens identifier, or a path to lens profile json file (relative to the `camera_presets` directory), or the json contents directly
        #[prost(string, optional, tag = "11")]
        pub lens_profile: ::core::option::Option<::prost::alloc::string::String>,
        /// IMU orientation used by Gyroflow as XYZ, Xyz, Zyx etc. Defaults to "XYZ". Read more in the Gyroflow documentation about this orientation convention.
        #[prost(string, optional, tag = "12")]
        pub imu_orientation: ::core::option::Option<::prost::alloc::string::String>,
        /// Arbitrary IMU rotation. Applies to the raw IMU samples (FrameMetadata.imu field).
        #[prost(message, optional, tag = "13")]
        pub imu_rotation: ::core::option::Option<super::Quaternion>,
        /// Arbitrary IMU rotation. Applies to the quaternions after sensor fusion (FrameMetadata.quaternions field).
        #[prost(message, optional, tag = "14")]
        pub quats_rotation: ::core::option::Option<super::Quaternion>,
        /// Optional note or additional data. If it starts with {, it will be parsed as JSON
        #[prost(string, optional, tag = "15")]
        pub additional_data: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClipMetadata {
        /// Video frame width in pixels
        #[prost(uint32, tag = "1")]
        pub frame_width: u32,
        /// Video frame height in pixels
        #[prost(uint32, tag = "2")]
        pub frame_height: u32,
        /// Clip duration in microseconds
        #[prost(float, tag = "3")]
        pub duration_us: f32,
        /// Recording frame rate
        #[prost(float, tag = "4")]
        pub record_frame_rate: f32,
        /// Sensor frame rate. In most cases it will be equal to `record_frame_rate`
        #[prost(float, tag = "5")]
        pub sensor_frame_rate: f32,
        /// File frame rate. May be different in VFR mode. e.g. 120 fps recorded as 30 fps file
        #[prost(float, tag = "6")]
        pub file_frame_rate: f32,
        /// Video rotation in degrees. For example 180 degrees for upside-down, or 90 for vertical mode.
        #[prost(int32, tag = "7")]
        pub rotation_degrees: i32,
        /// Sampling rate of the IMU chip.
        #[prost(uint32, tag = "8")]
        pub imu_sample_rate: u32,
        /// Shooting color profile, eg. Natural, Log, etc
        #[prost(string, optional, tag = "9")]
        pub color_profile: ::core::option::Option<::prost::alloc::string::String>,
        /// For anamorphic lenses
        #[prost(float, tag = "10")]
        pub pixel_aspect_ratio: f32,
        /// Time it takes to read the video frame from the sensor, for rolling shutter correction. NOTE: It should be the time between first row of pixels to the last row of pixels, not for full sensor readout (if the crop is involved).
        #[prost(float, tag = "11")]
        pub frame_readout_time_us: f32,
        /// Frame readout direction
        #[prost(enumeration = "clip_metadata::ReadoutDirection", tag = "12")]
        pub frame_readout_direction: i32,
    }
    /// Nested message and enum types in `ClipMetadata`.
    pub mod clip_metadata {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum ReadoutDirection {
            /// Sensor reads pixels from top to bottom.
            TopToBottom = 0,
            /// Sensor reads pixels from bottom to top.
            BottomToTop = 1,
            /// Sensor reads pixels from right to left.
            RightToLeft = 2,
            /// Sensor reads pixels from left to right.
            LeftToRight = 3,
        }
        impl ReadoutDirection {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::TopToBottom => "TopToBottom",
                    Self::BottomToTop => "BottomToTop",
                    Self::RightToLeft => "RightToLeft",
                    Self::LeftToRight => "LeftToRight",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "TopToBottom" => Some(Self::TopToBottom),
                    "BottomToTop" => Some(Self::BottomToTop),
                    "RightToLeft" => Some(Self::RightToLeft),
                    "LeftToRight" => Some(Self::LeftToRight),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameMetadata {
    /// Frame capture start - the timestamp when the first row of pixels was captured. Internal camera clock timestamp. Unit: microseconds
    #[prost(double, tag = "1")]
    pub start_timestamp_us: f64,
    /// Frame capture end - the timestamp when the last row of pixels was captured. Internal camera clock timestamp. Unit: microseconds
    #[prost(double, tag = "2")]
    pub end_timestamp_us: f64,
    /// Frame number in sequence. The first frame of the video clip should have this set to 1.
    #[prost(uint32, tag = "3")]
    pub frame_number: u32,
    /// ISO Value
    #[prost(uint32, optional, tag = "4")]
    pub iso: ::core::option::Option<u32>,
    /// Actual exposure time in microseconds
    #[prost(float, optional, tag = "5")]
    pub exposure_time_us: ::core::option::Option<f32>,
    /// White balance in kelvins
    #[prost(uint32, optional, tag = "6")]
    pub white_balance_kelvin: ::core::option::Option<u32>,
    /// White balance tint value
    #[prost(float, optional, tag = "7")]
    pub white_balance_tint: ::core::option::Option<f32>,
    /// Digital zoom ratio. If the video is zoomed in digitally, this value should indicate that. E.g. 0.9 for 10% digital crop
    #[prost(float, optional, tag = "8")]
    pub digital_zoom_ratio: ::core::option::Option<f32>,
    /// Shutter speed numerator. E.g. 1 in case of 1/240 shutter speed.
    #[prost(int32, optional, tag = "9")]
    pub shutter_speed_numerator: ::core::option::Option<i32>,
    /// Shutter speed denumerator. E.g. 240 in case of 1/240 shutter speed.
    #[prost(int32, optional, tag = "10")]
    pub shutter_speed_denumerator: ::core::option::Option<i32>,
    /// Shutter angle in degrees. E.g. 180
    #[prost(float, optional, tag = "11")]
    pub shutter_angle_degrees: ::core::option::Option<f32>,
    /// Sensor crop area in pixels, X coordinate
    #[prost(float, optional, tag = "12")]
    pub crop_x: ::core::option::Option<f32>,
    /// Sensor crop area in pixels, Y coordinate
    #[prost(float, optional, tag = "13")]
    pub crop_y: ::core::option::Option<f32>,
    /// Sensor crop area in pixels, width
    #[prost(float, optional, tag = "14")]
    pub crop_width: ::core::option::Option<f32>,
    /// Sensor crop area in pixels, height
    #[prost(float, optional, tag = "15")]
    pub crop_height: ::core::option::Option<f32>,
    /// Per-frame lens information, like focal length, distortion coefficients etc
    #[prost(message, repeated, tag = "16")]
    pub lens: ::prost::alloc::vec::Vec<LensData>,
    /// Per-frame raw IMU data samples, will likely have multiple samples in one video frame
    #[prost(message, repeated, tag = "17")]
    pub imu: ::prost::alloc::vec::Vec<ImuData>,
    /// Per-frame quaternion data. Optional, can contain camera orientation after sensor fusion
    #[prost(message, repeated, tag = "18")]
    pub quaternions: ::prost::alloc::vec::Vec<QuaternionData>,
    /// Per-frame Lens optical stabilization data. Not present when OIS is disabled.          ??? Exact data and format to be determined ???
    #[prost(message, repeated, tag = "19")]
    pub ois: ::prost::alloc::vec::Vec<LensOisData>,
    /// Per-frame in-body image stabilization (IBIS) data. Not present when IBIS is disabled. ??? Exact data and format to be determined ???
    #[prost(message, repeated, tag = "20")]
    pub ibis: ::prost::alloc::vec::Vec<IbisData>,
    /// Per-frame electronic in-camera stabilization data. Not present when EIS is disabled.  ??? Exact data and format to be determined ???
    #[prost(message, repeated, tag = "21")]
    pub eis: ::prost::alloc::vec::Vec<EisData>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LensData {
    #[prost(enumeration = "lens_data::DistortionModel", tag = "1")]
    pub distortion_model: i32,
    /// Distortion model coefficients as an array of float values.
    #[prost(float, repeated, tag = "2")]
    pub distortion_coefficients: ::prost::alloc::vec::Vec<f32>,
    /// Row-major 3x3 camera intrinsic matrix. Usually \[[fx, 0, cx\], \[0, fy, cy\], \[0, 0, 1]\], where fx and fy are focal length values in pixels (f_mm = f_pixels * sensor_width_mm / image_width_px ; f_pixels = f_mm / sensor_width_mm * image_width_px), and cx and cy is the principal point in pixels (usually width/2, height/2).
    #[prost(float, repeated, tag = "3")]
    pub camera_intrinsic_matrix: ::prost::alloc::vec::Vec<f32>,
    /// Native lens focal length in mm
    #[prost(float, optional, tag = "4")]
    pub focal_length_mm: ::core::option::Option<f32>,
    /// Lens aperture number. E.g. 2.8
    #[prost(float, optional, tag = "5")]
    pub f_number: ::core::option::Option<f32>,
    /// Focal plane distance in millimeters
    #[prost(float, optional, tag = "6")]
    pub focus_distance_mm: ::core::option::Option<f32>,
}
/// Nested message and enum types in `LensData`.
pub mod lens_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistortionModel {
        /// OpenCV's fisheye model. More details: <https://docs.opencv.org/4.x/db/d58/group__calib3d__fisheye.html>
        OpenCvFisheye = 0,
        /// OpenCV's standard model. More details: <https://docs.opencv.org/4.x/d9/d0c/group__calib3d.html>
        OpenCvStandard = 1,
        /// LensFun's Poly3 model. More details: <https://lensfun.github.io/manual/latest/group__Lens.html#gaa505e04666a189274ba66316697e308e>
        Poly3 = 2,
        /// LensFun's Poly5 model. More details: <https://lensfun.github.io/manual/latest/group__Lens.html#gaa505e04666a189274ba66316697e308e>
        Poly5 = 3,
        /// LensFun's PTLens model. More details: <https://lensfun.github.io/manual/latest/group__Lens.html#gaa505e04666a189274ba66316697e308e>
        PtLens = 4,
        /// ??? Not implemented yet. ???
        GenericPolynomial = 5,
    }
    impl DistortionModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OpenCvFisheye => "OpenCVFisheye",
                Self::OpenCvStandard => "OpenCVStandard",
                Self::Poly3 => "Poly3",
                Self::Poly5 => "Poly5",
                Self::PtLens => "PTLens",
                Self::GenericPolynomial => "GenericPolynomial",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OpenCVFisheye" => Some(Self::OpenCvFisheye),
                "OpenCVStandard" => Some(Self::OpenCvStandard),
                "Poly3" => Some(Self::Poly3),
                "Poly5" => Some(Self::Poly5),
                "PTLens" => Some(Self::PtLens),
                "GenericPolynomial" => Some(Self::GenericPolynomial),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImuData {
    /// Exact timestamp of the sampling time from the internal camera clock. Unit: microseconds
    #[prost(double, tag = "1")]
    pub sample_timestamp_us: f64,
    /// Gyroscope X reading. Unit: degrees/sec
    #[prost(float, tag = "2")]
    pub gyroscope_x: f32,
    /// Gyroscope Y reading. Unit: degrees/sec
    #[prost(float, tag = "3")]
    pub gyroscope_y: f32,
    /// Gyroscope Z reading. Unit: degrees/sec
    #[prost(float, tag = "4")]
    pub gyroscope_z: f32,
    /// Accelerometer X reading. Unit: m/s²
    #[prost(float, tag = "5")]
    pub accelerometer_x: f32,
    /// Accelerometer Y reading. Unit: m/s²
    #[prost(float, tag = "6")]
    pub accelerometer_y: f32,
    /// Accelerometer Z reading. Unit: m/s²
    #[prost(float, tag = "7")]
    pub accelerometer_z: f32,
    /// Magnetometer X reading. Unit: µT
    #[prost(float, optional, tag = "8")]
    pub magnetometer_x: ::core::option::Option<f32>,
    /// Magnetometer Y reading. Unit: µT
    #[prost(float, optional, tag = "9")]
    pub magnetometer_y: ::core::option::Option<f32>,
    /// Magnetometer Z reading. Unit: µT
    #[prost(float, optional, tag = "10")]
    pub magnetometer_z: ::core::option::Option<f32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Quaternion {
    /// Quaternion component W (angle)
    #[prost(float, tag = "1")]
    pub w: f32,
    /// Quaternion component X
    #[prost(float, tag = "2")]
    pub x: f32,
    /// Quaternion component Y
    #[prost(float, tag = "3")]
    pub y: f32,
    /// Quaternion component Z
    #[prost(float, tag = "4")]
    pub z: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuaternionData {
    /// Exact timestamp of the sampling time from the internal camera clock. Unit: microseconds
    #[prost(double, tag = "1")]
    pub sample_timestamp_us: f64,
    /// Quaternion
    #[prost(message, optional, tag = "2")]
    pub quat: ::core::option::Option<Quaternion>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LensOisData {
    /// Exact timestamp of the sampling time from the internal camera clock. Unit: microseconds
    #[prost(double, tag = "1")]
    pub sample_timestamp_us: f64,
    /// Optical element shift value in the X axis in nanometers
    #[prost(float, tag = "2")]
    pub x: f32,
    /// Optical element shift value in the Y axis in nanometers
    #[prost(float, tag = "3")]
    pub y: f32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IbisData {
    /// Exact timestamp of the sampling time from the internal camera clock. Unit: microseconds
    #[prost(double, tag = "1")]
    pub sample_timestamp_us: f64,
    /// X Sensor shift value in nanometers
    #[prost(float, tag = "2")]
    pub shift_x: f32,
    /// Y Sensor shift value in nanometers
    #[prost(float, tag = "3")]
    pub shift_y: f32,
    /// Sensor roll rotation angle in degrees.
    #[prost(float, tag = "4")]
    pub roll_angle_degrees: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EisData {
    /// Exact timestamp of the sampling time from the internal camera clock. Unit: microseconds. Timestamp is ignored if there's only one entry of EISData per frame.
    #[prost(double, optional, tag = "1")]
    pub sample_timestamp_us: ::core::option::Option<f64>,
    /// Type of EIS. Can be quaternion, mesh warp or 4x4 transform matrix.
    #[prost(enumeration = "eis_data::EisDataType", tag = "2")]
    pub r#type: i32,
    /// If type is QUATERNION, this field contains the quaternion data
    #[prost(message, optional, tag = "3")]
    pub quaternion: ::core::option::Option<Quaternion>,
    /// If type is MESH_WARP, this field contains the mesh values
    #[prost(message, optional, tag = "4")]
    pub mesh_warp: ::core::option::Option<MeshWarpData>,
    /// If type is MATRIX_4x4, this field contains the 16 float matrix values (row-major order).
    #[prost(float, repeated, tag = "5")]
    pub matrix_4x4: ::prost::alloc::vec::Vec<f32>,
}
/// Nested message and enum types in `EISData`.
pub mod eis_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EisDataType {
        /// Rotation only, indicates how the frame was rotated internally by the camera EIS, from pixels read from the sensor to the final pixels in the encoded video file.
        Quaternion = 0,
        /// Mesh warp. Allows for arbitrary mapping of the video frame. Contains exact transform/deform of the video frame read from the sensor to the final pixels in the encoded video file.
        MeshWarp = 1,
        /// 4x4 matrix - rotation, translation and scaling. Indicates how the frame was transformed in the 3d space by the camera EIS, from pixels read from the sensor to the final pixels in the encoded video file.
        Matrix4x4 = 2,
    }
    impl EisDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Quaternion => "QUATERNION",
                Self::MeshWarp => "MESH_WARP",
                Self::Matrix4x4 => "MATRIX_4X4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "QUATERNION" => Some(Self::Quaternion),
                "MESH_WARP" => Some(Self::MeshWarp),
                "MATRIX_4X4" => Some(Self::Matrix4x4),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeshWarpData {
    /// Number of video frame divisions in the horizontal direction.
    #[prost(int32, tag = "1")]
    pub grid_width: i32,
    /// Number of video frame divisions in the vertical direction.
    #[prost(int32, tag = "2")]
    pub grid_height: i32,
    /// grid_width * grid_height float numbers representing new position of a coordinate at X and Y grid position.
    #[prost(float, repeated, tag = "3")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
