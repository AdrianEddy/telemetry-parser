#![allow(dead_code)]
// This file is @generated by prost-build.
/// *
/// One clip can be part of the video file or part of the remote transfering content. It would include some essential
/// messages which are used to describe the basic information and to distinguish different clips. About the detailed
/// properties of the clip, we shall put them in a clip metadata message after ClipMetaHeader and shall not put them in
/// the header part. Note that this message shall be included in the ClipMeta.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClipMetaHeader {
    /// * The name of the product proto file. The max string length of
    /// it is 32 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub proto_file_name: ::prost::alloc::string::String,
    /// * The version of the library proto file. The max string length
    /// of it is 32 bytes (including ending symbol).
    #[prost(string, tag = "2")]
    pub library_proto_version: ::prost::alloc::string::String,
    /// * The version of the product proto file. The max string length
    /// of it is 32 bytes (including ending symbol).
    #[prost(string, tag = "3")]
    pub product_proto_version: ::prost::alloc::string::String,
    /// * The serial number of the product producing this clip. The
    /// max string length of it is 32 bytes (including ending
    /// symbol).
    #[prost(string, tag = "5")]
    pub product_sn: ::prost::alloc::string::String,
    /// * The firmware version of the product producing this clip. The
    /// max string length of it is 32 bytes (including ending
    /// symbol).
    #[prost(string, tag = "6")]
    pub product_firmware_version: ::prost::alloc::string::String,
    /// * The encryption type for encrypting metadata messages.
    #[prost(enumeration = "clip_meta_header::MetaEncryptionType", tag = "7")]
    pub meta_encryption_type: i32,
    /// * The compression type for compressing metadata messages.
    #[prost(enumeration = "clip_meta_header::MetaCompressionType", tag = "8")]
    pub meta_compression_type: i32,
    /// * The timestamp is the duration starting from the power-up
    /// time to the time that the first frame of this clip comes.
    /// Unit: micro-second.
    #[prost(uint64, tag = "9")]
    pub clip_timestamp: u64,
    /// * The name of this product. The max string length of it is 64
    /// bytes (including ending symbol).
    #[prost(string, tag = "10")]
    pub product_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ClipMetaHeader`.
pub mod clip_meta_header {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetaEncryptionType {
        /// * No encryption on metadata messages.
        None = 0,
    }
    impl MetaEncryptionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "META_ENCRYPTION_TYPE_NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "META_ENCRYPTION_TYPE_NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetaCompressionType {
        /// * No compression on metadata messages.
        None = 0,
    }
    impl MetaCompressionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "META_COMPRESSION_TYPE_NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "META_COMPRESSION_TYPE_NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
/// *
/// It would include some essential messages which are used to describe the basic information and to distinguish
/// different streams. About the detailed properties of the stream, we shall put them in a stream metadata message after
/// StreamMetaHeader and shall not put them in the header part. Note that this message shall be included in the
/// StreamMeta.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StreamMetaHeader {
    /// * The unique ID which is used to distinguish different streams
    /// having the same stream type.
    #[prost(uint32, tag = "1")]
    pub stream_id: u32,
    /// * The type of this stream.
    #[prost(enumeration = "stream_meta_header::StreamType", tag = "2")]
    pub stream_type: i32,
    /// * The stream alias name which is used to distinguish different
    /// streams intuitively for people. The max string length of it
    /// is 32 bytes (including ending symbol).
    #[prost(string, tag = "3")]
    pub stream_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `StreamMetaHeader`.
pub mod stream_meta_header {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StreamType {
        /// * The stream type is video.
        Video = 0,
        /// * The stream type is audio.
        Audio = 1,
    }
    impl StreamType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Video => "STREAM_TYPE_VIDEO",
                Self::Audio => "STREAM_TYPE_AUDIO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STREAM_TYPE_VIDEO" => Some(Self::Video),
                "STREAM_TYPE_AUDIO" => Some(Self::Audio),
                _ => None,
            }
        }
    }
}
/// *
/// It would include some essential messages which are used to describe the basic information and to distinguish
/// different frames. About the detailed properties of the frame, we shall put them in a frame metadata message after
/// FrameMetaHeader and shall not put them in the header part. Note that this message shall be included in the FrameMeta.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FrameMetaHeader {
    /// * The frame sequence number which is used to distinguish the
    /// different frame in a stream.
    #[prost(uint64, tag = "1")]
    pub frame_seq_num: u64,
    /// * The timestamp is the duration starting from the power-up
    /// time to the time that the this frame comes.
    /// Unit: micro-second.
    #[prost(uint64, tag = "2")]
    pub frame_timestamp: u64,
    /// * The stream id which this frame belongs to, to avoid the same
    /// frame sequence number in different stream.
    #[prost(uint32, tag = "3")]
    pub stream_id: u32,
    /// * The check code for metadata messages is enable or not.
    #[prost(bool, tag = "4")]
    pub check_code_enable: bool,
    /// * The check code type for checking metadata messages.
    #[prost(enumeration = "frame_meta_header::CheckCodeType", tag = "5")]
    pub check_code_type: i32,
    /// * The check code of this frame which does not include messages
    /// in FrameMetaHeader. When the type is CRC32, the CRC32 value
    /// will be filled in the low 32-bits and the high 32-bits is
    /// zero.
    #[prost(uint64, tag = "6")]
    pub check_code: u64,
}
/// Nested message and enum types in `FrameMetaHeader`.
pub mod frame_meta_header {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CheckCodeType {
        /// * No check code is used.
        None = 0,
        /// * The check code type is CRC32 (32-bit Cyclic Redundancy
        /// Check).
        Crc32 = 1,
    }
    impl CheckCodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::None => "CHECK_CODE_TYPE_NONE",
                Self::Crc32 => "CHECK_CODE_TYPE_CRC32",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CHECK_CODE_TYPE_NONE" => Some(Self::None),
                "CHECK_CODE_TYPE_CRC32" => Some(Self::Crc32),
                _ => None,
            }
        }
    }
}
/// *
/// It would include some essential messages which are used to distinguish the different devices. About the device
/// properties, we shall put them in a message after the metadata header of device and shall not put them in the header
/// part.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct MetaHeaderOfDevice {
    /// * The unique ID for distinguishing the different device.
    #[prost(uint32, tag = "1")]
    pub device_id: u32,
    /// * The type of this device is physical or virtual.
    #[prost(enumeration = "meta_header_of_device::DeviceType", tag = "2")]
    pub device_type: i32,
    /// * The specific type of this device such as camera body and
    /// drone.
    #[prost(enumeration = "meta_header_of_device::DeviceSubType", tag = "3")]
    pub device_sub_type: i32,
    /// * The device alias name which is used to distinguish different
    /// devices intuitively for people. The max string length of it
    /// is 32 bytes (including ending symbol).
    #[prost(string, tag = "4")]
    pub device_name: ::prost::alloc::string::String,
    /// * The metadata generated frequency of this device.
    /// Unit: Hz.
    #[prost(float, tag = "5")]
    pub device_frequency: f32,
    /// * The timestamp is the duration starting from the power-up
    /// time to the time that the current frame included in this
    /// device comes. Unit: micro-second.
    #[prost(uint64, tag = "6")]
    pub device_timestamp: u64,
}
/// Nested message and enum types in `MetaHeaderOfDevice`.
pub mod meta_header_of_device {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeviceType {
        /// * The device type is undefined.
        Undefined = 0,
        /// * The device type is physical.
        Physical = 1,
        /// * The device type is virtual.
        Virtual = 2,
    }
    impl DeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "DEVICE_TYPE_UNDEFINED",
                Self::Physical => "DEVICE_TYPE_PHYSICAL",
                Self::Virtual => "DEVICE_TYPE_VIRTUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEVICE_TYPE_UNDEFINED" => Some(Self::Undefined),
                "DEVICE_TYPE_PHYSICAL" => Some(Self::Physical),
                "DEVICE_TYPE_VIRTUAL" => Some(Self::Virtual),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeviceSubType {
        /// * The device sub-type is undefined.
        Undefined = 0,
        /// * The device sub-type is camera body.
        CameraBody = 1,
        /// * The device sub-type is drone.
        Drone = 2,
        /// * The device sub-type is gimbal.
        Gimbal = 3,
        /// * The device sub-type is gimbal z-axis.
        GimbalZaxis = 4,
        /// * The device sub-type is recorder.
        Recorder = 5,
        /// * The device sub-type is laser ranging.
        LaserRanging = 6,
    }
    impl DeviceSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "DEVICE_SUB_TYPE_UNDEFINED",
                Self::CameraBody => "DEVICE_SUB_TYPE_CAMERA_BODY",
                Self::Drone => "DEVICE_SUB_TYPE_DRONE",
                Self::Gimbal => "DEVICE_SUB_TYPE_GIMBAL",
                Self::GimbalZaxis => "DEVICE_SUB_TYPE_GIMBAL_ZAXIS",
                Self::Recorder => "DEVICE_SUB_TYPE_RECORDER",
                Self::LaserRanging => "DEVICE_SUB_TYPE_LASER_RANGING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DEVICE_SUB_TYPE_UNDEFINED" => Some(Self::Undefined),
                "DEVICE_SUB_TYPE_CAMERA_BODY" => Some(Self::CameraBody),
                "DEVICE_SUB_TYPE_DRONE" => Some(Self::Drone),
                "DEVICE_SUB_TYPE_GIMBAL" => Some(Self::Gimbal),
                "DEVICE_SUB_TYPE_GIMBAL_ZAXIS" => Some(Self::GimbalZaxis),
                "DEVICE_SUB_TYPE_RECORDER" => Some(Self::Recorder),
                "DEVICE_SUB_TYPE_LASER_RANGING" => Some(Self::LaserRanging),
                _ => None,
            }
        }
    }
}
/// *
/// It would include some essential messages which are used to distinguish the different sub-devices. About the
/// sub-device properties, we shall put them in a message after the metadata header of sub-device and shall not put them
/// in the header part.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct MetaHeaderOfSubDevice {
    /// * The unique ID for distinguishing the different
    /// sub-devices.
    #[prost(uint32, tag = "1")]
    pub sub_dev_id: u32,
    /// * The type of this sub-device is physical or virtual.
    #[prost(enumeration = "meta_header_of_sub_device::SubDeviceType", tag = "2")]
    pub sub_device_type: i32,
    /// * The specific type of this sub-device such as lens.
    #[prost(enumeration = "meta_header_of_sub_device::SubDeviceSubType", tag = "3")]
    pub sub_device_sub_type: i32,
    /// * The sub-device alias name which is used to distinguish
    /// different sub-devices intuitively for people. The max string
    /// length of it is 32 bytes (including ending symbol).
    #[prost(string, tag = "4")]
    pub sub_device_name: ::prost::alloc::string::String,
    /// * The metadata generated frequency of this sub-device.
    /// Unit: Hz.
    #[prost(float, tag = "5")]
    pub sub_device_frequency: f32,
    /// * The timestamp is the duration starting from the power-up
    /// time to the time that the current frame included in this
    /// sub-device comes. Unit: micro-second.
    #[prost(uint64, tag = "6")]
    pub sub_device_timestamp: u64,
}
/// Nested message and enum types in `MetaHeaderOfSubDevice`.
pub mod meta_header_of_sub_device {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubDeviceType {
        /// * The sub-device type is undefined.
        Undefined = 0,
        /// * The sub-device type is physical.
        Physical = 1,
        /// * The sub-device type is virtual.
        Virtual = 2,
    }
    impl SubDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "SUB_DEVICE_TYPE_UNDEFINED",
                Self::Physical => "SUB_DEVICE_TYPE_PHYSICAL",
                Self::Virtual => "SUB_DEVICE_TYPE_VIRTUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUB_DEVICE_TYPE_UNDEFINED" => Some(Self::Undefined),
                "SUB_DEVICE_TYPE_PHYSICAL" => Some(Self::Physical),
                "SUB_DEVICE_TYPE_VIRTUAL" => Some(Self::Virtual),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SubDeviceSubType {
        /// * The sub-device sub-type is undefined.
        Undefined = 0,
        /// * The sub-device sub-type is lens.
        Lens = 1,
    }
    impl SubDeviceSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "SUB_DEVICE_SUB_TYPE_UNDEFINED",
                Self::Lens => "SUB_DEVICE_SUB_TYPE_LENS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SUB_DEVICE_SUB_TYPE_UNDEFINED" => Some(Self::Undefined),
                "SUB_DEVICE_SUB_TYPE_LENS" => Some(Self::Lens),
                _ => None,
            }
        }
    }
}
/// *
/// The fixed feature of the specified video stream.
/// If it has been filled, it always follows the message StreamMetaHeader.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoStreamMeta {
    /// * The width of the resolution. Unit: pixel.
    #[prost(uint32, tag = "1")]
    pub resolution_width: u32,
    /// * The height of the resolution. Unit: pixel.
    #[prost(uint32, tag = "2")]
    pub resolution_height: u32,
    /// * The rate of video data sampling. Unit: frame/second.
    #[prost(float, tag = "3")]
    pub framerate: f32,
    #[prost(bool, tag = "4")]
    pub is_bit_depth_valid: bool,
    /// * The number of bits used for each color component.
    #[prost(uint32, tag = "5")]
    pub bit_depth: u32,
    /// * The bit format used for each color component.
    #[prost(enumeration = "video_stream_meta::BitFormatType", tag = "6")]
    pub bit_format: i32,
    /// * The user-specified type of this video stream such as slow
    /// motion and quick movie.
    #[prost(enumeration = "video_stream_meta::VideoStreamType", tag = "7")]
    pub video_stream_type: i32,
    /// * The compression format used for this video stream.
    #[prost(enumeration = "video_stream_meta::VideoCodecType", tag = "8")]
    pub video_codec_type: i32,
}
/// Nested message and enum types in `VideoStreamMeta`.
pub mod video_stream_meta {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BitFormatType {
        /// * The bit format is unknown.
        Unknown = 0,
        /// * The bit format is raw.
        Raw = 1,
        /// * The bit format is RGB.
        Rgb = 2,
        /// * The bit format is RGBA.
        Rgba = 3,
        /// * The bit format is YUV420.
        Yuv420 = 4,
        /// * The bit format is YUV422.
        Yuv422 = 5,
        /// * The bit format is YUV444.
        Yuv444 = 6,
    }
    impl BitFormatType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "BIT_FORMAT_TYPE_UNKNOWN",
                Self::Raw => "BIT_FORMAT_TYPE_RAW",
                Self::Rgb => "BIT_FORMAT_TYPE_RGB",
                Self::Rgba => "BIT_FORMAT_TYPE_RGBA",
                Self::Yuv420 => "BIT_FORMAT_TYPE_YUV420",
                Self::Yuv422 => "BIT_FORMAT_TYPE_YUV422",
                Self::Yuv444 => "BIT_FORMAT_TYPE_YUV444",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BIT_FORMAT_TYPE_UNKNOWN" => Some(Self::Unknown),
                "BIT_FORMAT_TYPE_RAW" => Some(Self::Raw),
                "BIT_FORMAT_TYPE_RGB" => Some(Self::Rgb),
                "BIT_FORMAT_TYPE_RGBA" => Some(Self::Rgba),
                "BIT_FORMAT_TYPE_YUV420" => Some(Self::Yuv420),
                "BIT_FORMAT_TYPE_YUV422" => Some(Self::Yuv422),
                "BIT_FORMAT_TYPE_YUV444" => Some(Self::Yuv444),
                _ => None,
            }
        }
    }
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoStreamType {
        /// * The video stream type is normal.
        Normal = 0,
        /// * The video stream type is delay.
        Delay = 1,
        /// * The video stream type is slow motion.
        SlowMotion = 2,
        /// * The video stream type is quick movie.
        QuickMovie = 3,
        /// * The video stream type is timeslapse.
        Timelapse = 4,
        /// * The video stream type is motionlapse.
        Motionlapse = 5,
        /// * The video stream type is hyperlapse.
        Hyperlapse = 6,
        /// * The video stream type is HDR.
        Hdr = 7,
        /// * The video stream type is loop record.
        LoopRecord = 8,
        /// * The video stream type is low light.
        LowLight = 9,
    }
    impl VideoStreamType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "VIDEO_STREAM_TYPE_NORMAL",
                Self::Delay => "VIDEO_STREAM_TYPE_DELAY",
                Self::SlowMotion => "VIDEO_STREAM_TYPE_SLOW_MOTION",
                Self::QuickMovie => "VIDEO_STREAM_TYPE_QUICK_MOVIE",
                Self::Timelapse => "VIDEO_STREAM_TYPE_TIMELAPSE",
                Self::Motionlapse => "VIDEO_STREAM_TYPE_MOTIONLAPSE",
                Self::Hyperlapse => "VIDEO_STREAM_TYPE_HYPERLAPSE",
                Self::Hdr => "VIDEO_STREAM_TYPE_HDR",
                Self::LoopRecord => "VIDEO_STREAM_TYPE_LOOP_RECORD",
                Self::LowLight => "VIDEO_STREAM_TYPE_LOW_LIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VIDEO_STREAM_TYPE_NORMAL" => Some(Self::Normal),
                "VIDEO_STREAM_TYPE_DELAY" => Some(Self::Delay),
                "VIDEO_STREAM_TYPE_SLOW_MOTION" => Some(Self::SlowMotion),
                "VIDEO_STREAM_TYPE_QUICK_MOVIE" => Some(Self::QuickMovie),
                "VIDEO_STREAM_TYPE_TIMELAPSE" => Some(Self::Timelapse),
                "VIDEO_STREAM_TYPE_MOTIONLAPSE" => Some(Self::Motionlapse),
                "VIDEO_STREAM_TYPE_HYPERLAPSE" => Some(Self::Hyperlapse),
                "VIDEO_STREAM_TYPE_HDR" => Some(Self::Hdr),
                "VIDEO_STREAM_TYPE_LOOP_RECORD" => Some(Self::LoopRecord),
                "VIDEO_STREAM_TYPE_LOW_LIGHT" => Some(Self::LowLight),
                _ => None,
            }
        }
    }
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoCodecType {
        /// * The video codec type is H264.
        H264 = 0,
        /// * The video codec type is H265.
        H265 = 1,
        /// * The video codec type is prores.
        Prores = 2,
        /// * The video codec type is prores raw.
        Proresraw = 3,
        /// * The video codec type is JPEG.
        Jpeg = 4,
        /// * The video codec type is JPEG 2000.
        Jpeg2000 = 5,
        /// * The video codec type is JPEG lossless.
        JpegLossless = 6,
    }
    impl VideoCodecType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::H264 => "VIDEO_CODEC_TYPE_H264",
                Self::H265 => "VIDEO_CODEC_TYPE_H265",
                Self::Prores => "VIDEO_CODEC_TYPE_PRORES",
                Self::Proresraw => "VIDEO_CODEC_TYPE_PRORESRAW",
                Self::Jpeg => "VIDEO_CODEC_TYPE_JPEG",
                Self::Jpeg2000 => "VIDEO_CODEC_TYPE_JPEG2000",
                Self::JpegLossless => "VIDEO_CODEC_TYPE_JPEG_LOSSLESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "VIDEO_CODEC_TYPE_H264" => Some(Self::H264),
                "VIDEO_CODEC_TYPE_H265" => Some(Self::H265),
                "VIDEO_CODEC_TYPE_PRORES" => Some(Self::Prores),
                "VIDEO_CODEC_TYPE_PRORESRAW" => Some(Self::Proresraw),
                "VIDEO_CODEC_TYPE_JPEG" => Some(Self::Jpeg),
                "VIDEO_CODEC_TYPE_JPEG2000" => Some(Self::Jpeg2000),
                "VIDEO_CODEC_TYPE_JPEG_LOSSLESS" => Some(Self::JpegLossless),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageProcessingQuality {
    /// * It is defined by DJI, which indicates different image
    /// processing in the ISP (Image Signal Processor)
    /// pipeline that represents different image quality.
    #[prost(
        enumeration = "image_processing_quality::ImageProcessingQualityType",
        tag = "1"
    )]
    pub image_processing_quality: i32,
}
/// Nested message and enum types in `ImageProcessingQuality`.
pub mod image_processing_quality {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageProcessingQualityType {
        /// * The image processing quality type is normal.
        Normal = 0,
        /// * The image processing quality type is high.
        High = 1,
    }
    impl ImageProcessingQualityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "IMAGE_PROCESSING_QUALITY_TYPE_NORMAL",
                Self::High => "IMAGE_PROCESSING_QUALITY_TYPE_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMAGE_PROCESSING_QUALITY_TYPE_NORMAL" => Some(Self::Normal),
                "IMAGE_PROCESSING_QUALITY_TYPE_HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ProresCodecQuality {
    /// * The value will be filled only when the video codec type is
    /// prores or prores raw.
    #[prost(enumeration = "prores_codec_quality::ProresCodecQualityType", tag = "1")]
    pub prores_codec_quality: i32,
}
/// Nested message and enum types in `ProresCodecQuality`.
pub mod prores_codec_quality {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProresCodecQualityType {
        /// * The prores codec quality is undefined.
        Undefined = 0,
        /// * The prores codec quality is proxy.
        Proxy = 1,
        /// * The prores codec quality is LT.
        Lt = 2,
        /// * The prores codec quality is standard.
        Sd = 3,
        /// * The prores codec quality is HQ.
        Hq = 4,
        /// * The prores codec quality is XQ.
        Xq = 5,
    }
    impl ProresCodecQualityType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Undefined => "PRORES_CODEC_QUALITY_TYPE_UNDEFINED",
                Self::Proxy => "PRORES_CODEC_QUALITY_TYPE_PROXY",
                Self::Lt => "PRORES_CODEC_QUALITY_TYPE_LT",
                Self::Sd => "PRORES_CODEC_QUALITY_TYPE_SD",
                Self::Hq => "PRORES_CODEC_QUALITY_TYPE_HQ",
                Self::Xq => "PRORES_CODEC_QUALITY_TYPE_XQ",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRORES_CODEC_QUALITY_TYPE_UNDEFINED" => Some(Self::Undefined),
                "PRORES_CODEC_QUALITY_TYPE_PROXY" => Some(Self::Proxy),
                "PRORES_CODEC_QUALITY_TYPE_LT" => Some(Self::Lt),
                "PRORES_CODEC_QUALITY_TYPE_SD" => Some(Self::Sd),
                "PRORES_CODEC_QUALITY_TYPE_HQ" => Some(Self::Hq),
                "PRORES_CODEC_QUALITY_TYPE_XQ" => Some(Self::Xq),
                _ => None,
            }
        }
    }
}
/// *
/// The multiple streams description in one clip.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ClipStreamsMeta {
    /// * The number of video stream track in this clip.
    #[prost(uint32, tag = "1")]
    pub video_stream_num: u32,
    /// * The number of audio stream track in this clip.
    #[prost(uint32, tag = "2")]
    pub audio_stream_num: u32,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceSn {
    /// * The serial number of this device. The max string length of
    /// it is 32 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub device_sn: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ENdSerialNumber {
    /// * The serial number of eND mounted. The max string length of
    /// it is 32 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub e_nd_sn: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct DeviceVersion {
    /// * The hardware version of this device. The max string length
    /// of it is 32 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub device_hw_version: ::prost::alloc::string::String,
    /// * The software version of this device. The max string length
    /// of it is 32 bytes (including ending symbol).
    #[prost(string, tag = "2")]
    pub device_sw_version: ::prost::alloc::string::String,
}
/// *
/// The user-specified cinema production information.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CinemaProductionInfo {
    /// * The user-specified name of the production. The max string
    /// length of it is 64 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub production: ::prost::alloc::string::String,
    /// * The user-specified name of the company producing the
    /// content. The max string length of it is 64 bytes (including
    /// ending symbol).
    #[prost(string, tag = "2")]
    pub production_company: ::prost::alloc::string::String,
    /// * The user-specified name of the director of the
    /// production. The max string length of it is 64 bytes
    /// (including ending symbol).
    #[prost(string, tag = "3")]
    pub director: ::prost::alloc::string::String,
    /// * The user-specified name of the cinematographer directing the
    /// recording. The max string length of it is 64 bytes
    /// (including ending symbol).
    #[prost(string, tag = "4")]
    pub cinematographer: ::prost::alloc::string::String,
    /// * The user-specified name of the camera operator. The max
    /// string length of it is 64 bytes (including ending
    /// symbol).
    #[prost(string, tag = "5")]
    pub cinema_operator: ::prost::alloc::string::String,
    /// * The user-specified name of the capturing location. The max
    /// string length of it is 64 bytes (including ending
    /// symbol).
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    /// * The user-specified number of the scene being captured.
    #[prost(uint32, tag = "7")]
    pub scene: u32,
    /// * The user-specified number of the take being captured.
    #[prost(uint32, tag = "8")]
    pub take: u32,
}
/// *
/// The cinema naming information of this clip.
/// For example, there is a video file A001C0001_190101_ABCD_001.MOV included in the directory A001_ABCD:
///      Camera index is A
///      Reel name is A001_ABCD
///      Camera ID is ABCD
///      Clip name is A001C0001_190101_ABCD.MOV
///      Spin name is A001C0001_190101_ABCD_001.MOV
/// Refer to each field of this message for more details.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CinemaClipNaming {
    /// * The user-specified camera index for identifying the
    /// individual camera unit (A - Z). The max string length of it
    /// is 8 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub camera_index: ::prost::alloc::string::String,
    /// * The name of the virtual reel which this clip belongs to. The
    /// max string length of it is 16 bytes (including ending
    /// symbol).
    #[prost(string, tag = "2")]
    pub reel_name: ::prost::alloc::string::String,
    /// * The name of the camera ID (or unique code) indicates that
    /// this clip is recoded by which camera. The max string length
    /// of it is 8 bytes (including ending symbol).
    #[prost(string, tag = "3")]
    pub camera_id: ::prost::alloc::string::String,
    /// * The name of this clip. The max string length of it is 32
    /// bytes (including ending symbol).
    #[prost(string, tag = "4")]
    pub clip_name: ::prost::alloc::string::String,
    /// * If a clip file is divided into multiple files, the spin name
    /// can indicate the different divided files. It will be the
    /// same as the clip name when there is no division. The max
    /// string length of it is 32 bytes (including ending
    /// symbol).
    #[prost(string, tag = "5")]
    pub spin_name: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProjectFps {
    /// * The user-specified framerate which the recoding project
    /// used. Unit: frame/second.
    #[prost(float, tag = "1")]
    pub project_fps: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageSizeType {
    /// * The user-specified image size which is the maximum area of a
    /// sample that the camera can image.
    #[prost(enumeration = "image_size_type::ImageSizeType", tag = "1")]
    pub image_size_type: i32,
}
/// Nested message and enum types in `ImageSizeType`.
pub mod image_size_type {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageSizeType {
        /// * The user-specified image size is default.
        Default = 0,
        /// * The user-specified image size is open gate.
        OpenGate = 1,
        /// * The user-specified image size is full frame.
        FullFrame = 2,
        /// * The user-specified image size is super 35.
        S35 = 3,
        /// * The user-specified image size is 4/3 inches.
        ImageSizeType43 = 4,
    }
    impl ImageSizeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "IMAGE_SIZE_TYPE_DEFAULT",
                Self::OpenGate => "IMAGE_SIZE_TYPE_OPEN_GATE",
                Self::FullFrame => "IMAGE_SIZE_TYPE_FULL_FRAME",
                Self::S35 => "IMAGE_SIZE_TYPE_S35",
                Self::ImageSizeType43 => "IMAGE_SIZE_TYPE_43",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IMAGE_SIZE_TYPE_DEFAULT" => Some(Self::Default),
                "IMAGE_SIZE_TYPE_OPEN_GATE" => Some(Self::OpenGate),
                "IMAGE_SIZE_TYPE_FULL_FRAME" => Some(Self::FullFrame),
                "IMAGE_SIZE_TYPE_S35" => Some(Self::S35),
                "IMAGE_SIZE_TYPE_43" => Some(Self::ImageSizeType43),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FovType {
    /// * The user-specified FOV (Field of View), which is the maximum
    /// area of a sample that the camera can image.
    #[prost(enumeration = "fov_type::FovType", tag = "1")]
    pub fov_type: i32,
}
/// Nested message and enum types in `FOVType`.
pub mod fov_type {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FovType {
        /// * The user-specified FOV is default.
        Default = 0,
        /// * The user-specified FOV is normal.
        Normal = 1,
        /// * The user-specified FOV is narrow.
        Narrow = 2,
        /// * The user-specified FOV is wide.
        Wide = 3,
        /// * The user-specified FOV is snarrow.
        Snarrow = 4,
        /// * The user-specified FOV is natural wide.
        NaturalWide = 5,
    }
    impl FovType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "FOV_TYPE_DEFAULT",
                Self::Normal => "FOV_TYPE_NORMAL",
                Self::Narrow => "FOV_TYPE_NARROW",
                Self::Wide => "FOV_TYPE_WIDE",
                Self::Snarrow => "FOV_TYPE_SNARROW",
                Self::NaturalWide => "FOV_TYPE_NATURAL_WIDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FOV_TYPE_DEFAULT" => Some(Self::Default),
                "FOV_TYPE_NORMAL" => Some(Self::Normal),
                "FOV_TYPE_NARROW" => Some(Self::Narrow),
                "FOV_TYPE_WIDE" => Some(Self::Wide),
                "FOV_TYPE_SNARROW" => Some(Self::Snarrow),
                "FOV_TYPE_NATURAL_WIDE" => Some(Self::NaturalWide),
                _ => None,
            }
        }
    }
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageArea {
    /// * A rectangle zone of valid pixel in photosite data array used
    /// in recording, composed of the left-top location (horizonal
    /// first), width and height of the area in order.
    #[prost(uint32, repeated, tag = "1")]
    pub active_image_area: ::prost::alloc::vec::Vec<u32>,
    /// * A rectangle zone of whole photosite data array used in
    /// recording, including active image area and any extra
    /// photosite data, composed of the left-top location (horizonal
    /// first), width and height of the area in order.
    #[prost(uint32, repeated, tag = "2")]
    pub full_image_area: ::prost::alloc::vec::Vec<u32>,
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CfaPattern {
    /// * The Bayer arrangement of color filters on a square grid of
    /// photosensors.
    #[prost(enumeration = "cfa_pattern::CfaPatternType", tag = "1")]
    pub cfa_pattern: i32,
}
/// Nested message and enum types in `CFAPattern`.
pub mod cfa_pattern {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CfaPatternType {
        /// * The CFA pattern is RGGB.
        Rggb = 0,
        /// * The CFA pattern is GRBG.
        Grbg = 1,
        /// * The CFA pattern is BGGR.
        Bggr = 2,
        /// * The CFA pattern is GBRG.
        Gbrg = 3,
    }
    impl CfaPatternType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Rggb => "CFA_PATTERN_TYPE_RGGB",
                Self::Grbg => "CFA_PATTERN_TYPE_GRBG",
                Self::Bggr => "CFA_PATTERN_TYPE_BGGR",
                Self::Gbrg => "CFA_PATTERN_TYPE_GBRG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CFA_PATTERN_TYPE_RGGB" => Some(Self::Rggb),
                "CFA_PATTERN_TYPE_GRBG" => Some(Self::Grbg),
                "CFA_PATTERN_TYPE_BGGR" => Some(Self::Bggr),
                "CFA_PATTERN_TYPE_GBRG" => Some(Self::Gbrg),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct BayerGreenSplit {
    /// * The difference between the values of the green pixels in the
    /// blue/green rows and the values of the green pixels in the
    /// red/green rows. Usually it only be available for CFA images
    /// from the Bayer pattern filter array. Refer to the DNG
    /// specification for more details, and only the type is
    /// different (type is long in the DNG specification) for higher
    /// precision.
    #[prost(float, tag = "1")]
    pub bayer_green_split: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ColorSpace {
    /// * The specific transformation of image data will be used in
    /// the nominal processing algorithm.
    #[prost(enumeration = "color_space::ColorSpaceType", tag = "1")]
    pub color_space: i32,
}
/// Nested message and enum types in `ColorSpace`.
pub mod color_space {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ColorSpaceType {
        /// * The color space is default.
        Default = 0,
        /// * The color space is D-Gamut.
        Dgamut = 1,
        /// * The color space is REC709.
        Rec709 = 2,
        /// * The color space is BT2020.
        Bt2020 = 3,
        /// * The color space is BT2100.
        Bt2100 = 4,
    }
    impl ColorSpaceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Default => "COLOR_SPACE_TYPE_DEFAULT",
                Self::Dgamut => "COLOR_SPACE_TYPE_DGAMUT",
                Self::Rec709 => "COLOR_SPACE_TYPE_REC709",
                Self::Bt2020 => "COLOR_SPACE_TYPE_BT2020",
                Self::Bt2100 => "COLOR_SPACE_TYPE_BT2100",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLOR_SPACE_TYPE_DEFAULT" => Some(Self::Default),
                "COLOR_SPACE_TYPE_DGAMUT" => Some(Self::Dgamut),
                "COLOR_SPACE_TYPE_REC709" => Some(Self::Rec709),
                "COLOR_SPACE_TYPE_BT2020" => Some(Self::Bt2020),
                "COLOR_SPACE_TYPE_BT2100" => Some(Self::Bt2100),
                _ => None,
            }
        }
    }
}
/// *
/// This is a sub-message only quoted by the message ColorMatrix.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct ColorMatrixBox {
    /// * It stores 3x3 matrix in row-major order. Refer to the
    /// message ColorMatrix for more detail about the definition of
    /// the color matrix.
    #[prost(float, repeated, tag = "1")]
    pub color_matrix: ::prost::alloc::vec::Vec<f32>,
}
/// *
/// It will contains the message ColorMatrixBox.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct ColorMatrix {
    /// * Each box will contain a color matrix, which transforms
    /// linear RGB pixel values in the camera native color space to
    /// CIE 1931 XYZ values relative to the D65 illuminant under the
    /// specified illuminant described in the message
    /// CalibrationIlluminant.
    #[prost(message, repeated, tag = "1")]
    pub color_matrix_box: ::prost::alloc::vec::Vec<ColorMatrixBox>,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CalibrationIlluminant {
    /// * The illuminants used in color calibration with the message
    /// ColorMatrix in order. Unit: Kelvin.
    #[prost(int32, repeated, tag = "1")]
    pub calibration_illuminant: ::prost::alloc::vec::Vec<i32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct NoiseReductionApplied {
    /// * The denoise strength applied on the image with range from
    /// -10.0 to +10.0. 0 is the default strength.
    #[prost(float, tag = "1")]
    pub noise_reduction_applied: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Saturation {
    /// * The factor by which the saturation of the image is altered
    /// in the conversion to the target color space with range from
    /// -10.0 to +10.0. 0 is the default strength. For raw image, it
    /// will be only applied on liveview or while for yuv image, it
    /// will be applied on image data.
    #[prost(float, tag = "1")]
    pub saturation: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Sharpness {
    /// * The factor by which the sharpness of the image is altered in
    /// the conversion to the target color space with range from
    /// -10.0 to +10.0. 0 is the default strength. For raw image, it
    /// will be only applied on liveview or while for yuv image, it
    /// will be applied on image data.
    #[prost(float, tag = "1")]
    pub sharpness: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct PixelAspectRatio {
    /// * The factor be used to stretch reconstructed pixel data
    /// horizontally to compensate for anamorphic distortion.
    #[prost(float, tag = "1")]
    pub pixel_aspect_ratio: f32,
}
/// *
/// It stores the specific or custom three-dimensional look up table (3D LUT) file.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LookUpTable3DFile {
    /// * The name of the 3D-LUT file. The max string length of it is
    /// 256 bytes (including ending symbol).
    #[prost(string, tag = "1")]
    pub lut3d_file_name: ::prost::alloc::string::String,
    /// * The data of the 3D-LUT file. The actual value type of it is
    /// 32-bits float, so you should convert from byte array to
    /// float array. For example, if you use the functions
    /// ParseFromString() and MessageToDict() in python for decoding
    /// protobuf, you should do b64decode() first and then convert
    /// four bytes to one float by the little-endian mode.
    #[prost(bytes = "vec", tag = "2")]
    pub lut3d_file_data: ::prost::alloc::vec::Vec<u8>,
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ColorProcessingVersion {
    /// * The color processing version of reference image processing
    /// flows, which describes specific op groups shoule be applied
    /// at the appropriate stages in the image processing pipeline.
    /// Each op group can include several ops which should be
    /// processed sequentially. For version 1.0.0.0, there are 4 op
    /// groups defined.
    #[prost(string, tag = "1")]
    pub color_processing_version: ::prost::alloc::string::String,
}
/// *
/// Once op(operation) which contains type and data in the op group.
/// This is a sub-message only quoted by the message OpGroup.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct OpBox {
    /// * The type of this operation which is used.
    #[prost(enumeration = "op_box::OpType", tag = "1")]
    pub r#type: i32,
    /// * The data of this operation which is used. The actual value
    /// type of it is 32-bits float, so you should convert from byte
    /// array to float array. For example, if you use the functions
    /// ParseFromString() and MessageToDict() in python for decoding
    /// protobuf, you should do b64decode() first and then convert
    /// four bytes to one float by the little-endian mode.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `OpBox`.
pub mod op_box {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OpType {
        /// * The operation type is the warp rectilinear.
        WarpRectilinear = 0,
        /// * The operation type is the warp fisheye.
        WarpFisheye = 1,
        /// * The operation type is the fix vignette radial.
        FixVignetteRadial = 2,
        /// * The operation type is the trim bounds.
        TrimBounds = 3,
        /// * The operation type is the map table.
        MapTable = 4,
        /// * The operation type is the map polynomial.
        MapPolynomial = 5,
        /// * The operation type is the gain map.
        GainMap = 6,
        /// * The operation type is the delta per row.
        DeltaPerRow = 7,
        /// * The operation type is the delta per column.
        DeltaPerColumn = 8,
        /// * The operation type is the scale per row.
        ScalePerRow = 9,
        /// * The operation type is the scale per column.
        ScalePerColumn = 10,
    }
    impl OpType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::WarpRectilinear => "OP_TYPE_WARP_RECTILINEAR",
                Self::WarpFisheye => "OP_TYPE_WARP_FISHEYE",
                Self::FixVignetteRadial => "OP_TYPE_FIX_VIGNETTE_RADIAL",
                Self::TrimBounds => "OP_TYPE_TRIM_BOUNDS",
                Self::MapTable => "OP_TYPE_MAP_TABLE",
                Self::MapPolynomial => "OP_TYPE_MAP_POLYNOMIAL",
                Self::GainMap => "OP_TYPE_GAIN_MAP",
                Self::DeltaPerRow => "OP_TYPE_DELTA_PER_ROW",
                Self::DeltaPerColumn => "OP_TYPE_DELTA_PER_COLUMN",
                Self::ScalePerRow => "OP_TYPE_SCALE_PER_ROW",
                Self::ScalePerColumn => "OP_TYPE_SCALE_PER_COLUMN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OP_TYPE_WARP_RECTILINEAR" => Some(Self::WarpRectilinear),
                "OP_TYPE_WARP_FISHEYE" => Some(Self::WarpFisheye),
                "OP_TYPE_FIX_VIGNETTE_RADIAL" => Some(Self::FixVignetteRadial),
                "OP_TYPE_TRIM_BOUNDS" => Some(Self::TrimBounds),
                "OP_TYPE_MAP_TABLE" => Some(Self::MapTable),
                "OP_TYPE_MAP_POLYNOMIAL" => Some(Self::MapPolynomial),
                "OP_TYPE_GAIN_MAP" => Some(Self::GainMap),
                "OP_TYPE_DELTA_PER_ROW" => Some(Self::DeltaPerRow),
                "OP_TYPE_DELTA_PER_COLUMN" => Some(Self::DeltaPerColumn),
                "OP_TYPE_SCALE_PER_ROW" => Some(Self::ScalePerRow),
                "OP_TYPE_SCALE_PER_COLUMN" => Some(Self::ScalePerColumn),
                _ => None,
            }
        }
    }
}
/// *
/// Every op(operation) group defines several ops should be applied in specific locations of normal image processing
/// pipeline sequentially.
/// It will contains the message OpBox.
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct OpGroup {
    /// * The op group1 includes operation(op)s that should applied
    /// sequentially to the raw image as read directly from the
    /// file.
    #[prost(message, repeated, tag = "1")]
    pub op_group1: ::prost::alloc::vec::Vec<OpBox>,
    /// * The op group2 includes operation(op)s that should applied
    /// sequentially to the raw image after linear mapping (always
    /// before the demosaicing).
    #[prost(message, repeated, tag = "2")]
    pub op_group2: ::prost::alloc::vec::Vec<OpBox>,
    /// * The op group3 includes operation(op)s that should applied
    /// sequentially to image just after demosaicing process.
    #[prost(message, repeated, tag = "3")]
    pub op_group3: ::prost::alloc::vec::Vec<OpBox>,
    /// * The op group4 includes operation(op)s that should applied
    /// sequentially to image after normal image processing (always
    /// after tone mapping and in yuv domain).
    #[prost(message, repeated, tag = "4")]
    pub op_group4: ::prost::alloc::vec::Vec<OpBox>,
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct NoiseProfile {
    /// * The amount of noise in a raw image at time of capture.
    #[prost(double, repeated, tag = "1")]
    pub noise_profile: ::prost::alloc::vec::Vec<f64>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImageDataSize {
    /// * The size in bytes of stored frame data.
    #[prost(uint32, tag = "1")]
    pub image_data_size: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExposureIndex {
    /// * The index of effective exposure selected on camera at time
    /// of image data capture.
    #[prost(float, tag = "1")]
    pub exposure_index: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Iso {
    /// * The sensitivity (the signal gain) of the camera system.
    #[prost(float, tag = "1")]
    pub iso: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExposureTime {
    /// * The exposure time (or the shutter speed) is the length of
    /// time that the camera sensor is exposed to light. Its value
    /// will be described as rational type, so for example, when
    /// exposure time is 1/50, its value will be \[1, 50\]. It is the
    /// real value and its denominator is rounded to the integer, so
    /// it has slightly different from the user-specified value.
    /// When the message ExposureTime and ShutterAngle are both
    /// filled and user-specified shutter unit is shutter angle, its
    /// value can be calculated by the formula:
    /// ExposureTime = ShutterAngle / (framerate * 360).
    /// Unit: second.
    #[prost(int32, repeated, tag = "1")]
    pub exposure_time: ::prost::alloc::vec::Vec<i32>,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FNumber {
    /// * The ratio of the focal length to the aperture in an optical
    /// system. Its value will be described as rational type, so for
    /// example, when F-number is F2.8, its value will be \[28, 10\].
    /// \[0, 0\] means the F-number is invalid or unknown. It is the
    /// real value so it has slightly different from the
    /// user-specified value.
    #[prost(uint32, repeated, tag = "1")]
    pub f_number: ::prost::alloc::vec::Vec<u32>,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ApertureValue {
    /// * The lens aperture in the APEX (Additive System of
    /// Photographic Exposure) value unit. The relation of the
    /// aperture value to F-number follows the formula:
    /// ApertureValue = 2 * log2(FNumber).
    /// Its value will be described as rational type, so for
    /// example, when aperture value is 3.61, its value will be
    /// \[361, 100\].
    #[prost(uint32, repeated, tag = "1")]
    pub aperture_value: ::prost::alloc::vec::Vec<u32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShutterAngle {
    /// * The shutter angle is exposure period expressed as an angle
    /// in seconds. When the message ExposureTime and ShutterAngle
    /// are both filled and user-specified shutter unit is exposure
    /// time, its value can be calculated by the formula:
    /// ShutterAngle = (framerate * 360) * ExposureTime.
    /// Unit: degree.
    #[prost(float, tag = "1")]
    pub shutter_angle: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FocusDistance {
    /// * The specified unit for the focus distance.
    #[prost(enumeration = "focus_distance::FocusUnit", tag = "1")]
    pub focus_unit: i32,
    /// * The focus distance in the specified focus unit, which
    /// indicates current distance at that the lens focuses. 0 means
    /// the focus distance is invalid or unknown.
    #[prost(int32, tag = "2")]
    pub focus_distance: i32,
}
/// Nested message and enum types in `FocusDistance`.
pub mod focus_distance {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FocusUnit {
        /// * The focus distance unit is in thousandths of an inch.
        FocusUnit1000Inch = 0,
        /// * The focus distance unit is millimeter.
        Millimetre = 1,
    }
    impl FocusUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FocusUnit1000Inch => "FOCUS_UNIT_1000_INCH",
                Self::Millimetre => "FOCUS_UNIT_MILLIMETRE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FOCUS_UNIT_1000_INCH" => Some(Self::FocusUnit1000Inch),
                "FOCUS_UNIT_MILLIMETRE" => Some(Self::Millimetre),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FocalLength {
    /// * The distance from the center of the lens to the focal points
    /// of the lens. 0 means the focal length is invalid or unknown.
    /// Its value will be described as rational type, so for
    /// example, when focal length is 35, its value will be
    /// \[35000, 1000\]. Unit: milli-meter.
    #[prost(int32, repeated, tag = "1")]
    pub focal_length: ::prost::alloc::vec::Vec<i32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SensorZoomRatio {
    /// * The sensor zoom ratio of current frame. The sensor zoom ratio is
    /// related to sensor mode's crop params, so for example, IMX586's
    /// full size is 8000*6000 pixels, if the sensor mode crops the middle
    /// 4000*3000 pixels as output, the sensor zoom ratio will be 2.
    #[prost(float, tag = "1")]
    pub sensor_zoom_ratio: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct OpticalZoomRatio {
    /// * The optical zoom ratio of current frame.
    #[prost(float, tag = "1")]
    pub optical_zoom_ratio: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigitalZoomRatio {
    /// * The digital zoom ratio of current frame.
    #[prost(float, tag = "1")]
    pub digital_zoom_ratio: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WhiteBalanceCct {
    /// * The white balance color temperature (CCT), selected at the
    /// time of capture. Unit: Kelvin.
    #[prost(uint32, tag = "1")]
    pub white_balance_cct: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct WhiteBalanceTint {
    /// * The deviation from blackbody radiator, with range from -99.0
    /// to +99.0.
    #[prost(float, tag = "1")]
    pub white_balance_tint: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct AsShotNeutral {
    /// * The white balance in the normalized coordinates of a
    /// perfectly neutral color in linear reference space values.
    #[prost(float, repeated, tag = "1")]
    pub as_shot_neutral: ::prost::alloc::vec::Vec<f32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct NdFilter {
    /// * The flag indicates whether the ND filter is enable.
    #[prost(bool, tag = "1")]
    pub nd_filter_enable: bool,
    /// * The optical density of ND filter. Unit: reciprocal of the
    /// attenuation ratio. 1.0 means a clear filter.
    #[prost(float, tag = "2")]
    pub nd_density: f32,
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct BlackLevel {
    /// * The offset of the raw sample values.
    #[prost(float, repeated, tag = "1")]
    pub black_level: ::prost::alloc::vec::Vec<f32>,
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct WhiteLevel {
    /// * The fully saturated encoding level for the raw sample
    /// value.
    #[prost(float, tag = "1")]
    pub white_level: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct TimeCode {
    /// * The user-specified run mode of the timecode which includes
    /// cam_free run mode and record run mode.
    #[prost(enumeration = "time_code::TimecodeRunMode", tag = "1")]
    pub timecode_run_mode: i32,
    /// * A sequence of numeric codes generated at regular intervals
    /// by a timing synchronization system. The max string length of
    /// it is 12 bytes (including ending symbol).
    #[prost(string, tag = "2")]
    pub timecode: ::prost::alloc::string::String,
    /// * The zero-based count of frame within the current seconds
    /// worth of timecode, in support of frame rates higher than
    /// those which can be encoded in SMPTE timecode.
    #[prost(uint32, tag = "3")]
    pub sub_second_frame_count: u32,
}
/// Nested message and enum types in `TimeCode`.
pub mod time_code {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimecodeRunMode {
        /// * The timecode run mode is cam_free run.
        Free = 0,
        /// * The timecode run mode is record run.
        Record = 1,
    }
    impl TimecodeRunMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Free => "TIMECODE_RUN_MODE_FREE",
                Self::Record => "TIMECODE_RUN_MODE_RECORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIMECODE_RUN_MODE_FREE" => Some(Self::Free),
                "TIMECODE_RUN_MODE_RECORD" => Some(Self::Record),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Orientation {
    /// * Any top-to-bottom reversals (flips) or left-to-right
    /// reversals (flops) that are performed on image data for
    /// evaluative viewing. Note that it just effects reference
    /// display method.
    #[prost(enumeration = "orientation::OrientationType", tag = "1")]
    pub orientation: i32,
}
/// Nested message and enum types in `Orientation`.
pub mod orientation {
    #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OrientationType {
        /// * No flipping or flopping is desired.
        OrientationNoReverse = 0,
        /// * Any displayed image are flopped (horizontally reversed
        /// relative to original scene), i.e.  horizontally 180.
        OrientationHReverse = 1,
        /// * Any displayed image are flipped (vertically reversed
        /// relative to original scene), vertically 180.
        OrientationVReverse = 2,
        /// * Any displayed image are rotated 180 (that is, vertically
        /// and horizontally reversed relative to original scene).
        OrientationHvReverse = 3,
        /// * Image are rotated 90 horizontally,
        /// i.e. rotate clockwise 90, with right side at the bottom.
        OrientationH90 = 4,
        /// * Image are rotated 270 horizontally,
        /// i.e. rotate clockwise 270, with left side at the bottom.
        OrientationH270 = 5,
    }
    impl OrientationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::OrientationNoReverse => "ORIENTATION_NO_REVERSE",
                Self::OrientationHReverse => "ORIENTATION_H_REVERSE",
                Self::OrientationVReverse => "ORIENTATION_V_REVERSE",
                Self::OrientationHvReverse => "ORIENTATION_HV_REVERSE",
                Self::OrientationH90 => "ORIENTATION_H_90",
                Self::OrientationH270 => "ORIENTATION_H_270",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ORIENTATION_NO_REVERSE" => Some(Self::OrientationNoReverse),
                "ORIENTATION_H_REVERSE" => Some(Self::OrientationHReverse),
                "ORIENTATION_V_REVERSE" => Some(Self::OrientationVReverse),
                "ORIENTATION_HV_REVERSE" => Some(Self::OrientationHvReverse),
                "ORIENTATION_H_90" => Some(Self::OrientationH90),
                "ORIENTATION_H_270" => Some(Self::OrientationH270),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ColorMode {
    /// * The user-specified color profile for video recording.
    #[prost(enumeration = "color_mode::ColorModeType", tag = "1")]
    pub color_mode: i32,
}
/// Nested message and enum types in `ColorMode`.
pub mod color_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ColorModeType {
        /// * The color mode is default.
        ColorModeDefault = 0,
        /// * The color mode is D-Cinelike.
        ColorModeDCinelike = 1,
        /// * The color mode is D-Log.
        ColorModeDLog = 2,
        /// * The color mode is film A.
        ColorModeFilmA = 3,
        /// * The color mode is film B.
        ColorModeFilmB = 4,
        /// * The color mode is film C.
        ColorModeFilmC = 5,
        /// * The color mode is film D.
        ColorModeFilmD = 6,
        /// * The color mode is film E.
        ColorModeFilmE = 7,
        /// * The color mode is film F.
        ColorModeFilmF = 8,
        /// * The color mode is HLG.
        ColorModeHlg = 9,
        /// * The color mode is art.
        ColorModeArt = 10,
        /// * The color mode is black & white.
        ColorModeBw = 11,
        /// * The color mode is vivid.
        ColorModeVivid = 12,
        /// * The color mode is beach.
        ColorModeBeach = 13,
        /// * The color mode is dream.
        ColorModeDream = 14,
        /// * The color mode is sRGB.
        ColorModeSrgb = 15,
        /// * The color mode is adobe RGB.
        ColorModeAdobergb = 16,
        /// * The color mode is IR cut.
        ColorModeIrCut = 17,
        /// * The color mode is racing.
        ColorModeRacing = 18,
        /// * The color mode is DLog-M.
        ColorModeDlogM = 19,
        /// * The color mode is Laser Fill Light.
        ColorModeLaserFillLight = 20,
        /// * The color mode is Spot Light.
        ColorModeSpotLight = 21,
    }
    impl ColorModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ColorModeDefault => "COLOR_MODE_DEFAULT",
                Self::ColorModeDCinelike => "COLOR_MODE_D_CINELIKE",
                Self::ColorModeDLog => "COLOR_MODE_D_LOG",
                Self::ColorModeFilmA => "COLOR_MODE_FILM_A",
                Self::ColorModeFilmB => "COLOR_MODE_FILM_B",
                Self::ColorModeFilmC => "COLOR_MODE_FILM_C",
                Self::ColorModeFilmD => "COLOR_MODE_FILM_D",
                Self::ColorModeFilmE => "COLOR_MODE_FILM_E",
                Self::ColorModeFilmF => "COLOR_MODE_FILM_F",
                Self::ColorModeHlg => "COLOR_MODE_HLG",
                Self::ColorModeArt => "COLOR_MODE_ART",
                Self::ColorModeBw => "COLOR_MODE_BW",
                Self::ColorModeVivid => "COLOR_MODE_VIVID",
                Self::ColorModeBeach => "COLOR_MODE_BEACH",
                Self::ColorModeDream => "COLOR_MODE_DREAM",
                Self::ColorModeSrgb => "COLOR_MODE_SRGB",
                Self::ColorModeAdobergb => "COLOR_MODE_ADOBERGB",
                Self::ColorModeIrCut => "COLOR_MODE_IR_CUT",
                Self::ColorModeRacing => "COLOR_MODE_RACING",
                Self::ColorModeDlogM => "COLOR_MODE_DLOG_M",
                Self::ColorModeLaserFillLight => "COLOR_MODE_LASER_FILL_LIGHT",
                Self::ColorModeSpotLight => "COLOR_MODE_SPOT_LIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COLOR_MODE_DEFAULT" => Some(Self::ColorModeDefault),
                "COLOR_MODE_D_CINELIKE" => Some(Self::ColorModeDCinelike),
                "COLOR_MODE_D_LOG" => Some(Self::ColorModeDLog),
                "COLOR_MODE_FILM_A" => Some(Self::ColorModeFilmA),
                "COLOR_MODE_FILM_B" => Some(Self::ColorModeFilmB),
                "COLOR_MODE_FILM_C" => Some(Self::ColorModeFilmC),
                "COLOR_MODE_FILM_D" => Some(Self::ColorModeFilmD),
                "COLOR_MODE_FILM_E" => Some(Self::ColorModeFilmE),
                "COLOR_MODE_FILM_F" => Some(Self::ColorModeFilmF),
                "COLOR_MODE_HLG" => Some(Self::ColorModeHlg),
                "COLOR_MODE_ART" => Some(Self::ColorModeArt),
                "COLOR_MODE_BW" => Some(Self::ColorModeBw),
                "COLOR_MODE_VIVID" => Some(Self::ColorModeVivid),
                "COLOR_MODE_BEACH" => Some(Self::ColorModeBeach),
                "COLOR_MODE_DREAM" => Some(Self::ColorModeDream),
                "COLOR_MODE_SRGB" => Some(Self::ColorModeSrgb),
                "COLOR_MODE_ADOBERGB" => Some(Self::ColorModeAdobergb),
                "COLOR_MODE_IR_CUT" => Some(Self::ColorModeIrCut),
                "COLOR_MODE_RACING" => Some(Self::ColorModeRacing),
                "COLOR_MODE_DLOG_M" => Some(Self::ColorModeDlogM),
                "COLOR_MODE_LASER_FILL_LIGHT" => Some(Self::ColorModeLaserFillLight),
                "COLOR_MODE_SPOT_LIGHT" => Some(Self::ColorModeSpotLight),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExposureIndexMode {
    /// * If the exposure index mode is on, it means that the exposure
    /// index value is valid.
    #[prost(enumeration = "exposure_index_mode::ExposureIndexModeType", tag = "1")]
    pub exposure_index_mode: i32,
}
/// Nested message and enum types in `ExposureIndexMode`.
pub mod exposure_index_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExposureIndexModeType {
        /// * The exposure index mode is off.
        EiModeOff = 0,
        /// * The exposure index mode is on.
        EiModeOn = 1,
    }
    impl ExposureIndexModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EiModeOff => "EI_MODE_OFF",
                Self::EiModeOn => "EI_MODE_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EI_MODE_OFF" => Some(Self::EiModeOff),
                "EI_MODE_ON" => Some(Self::EiModeOn),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GainMode {
    /// * The user-specified gain mode which will determining the
    /// sensor conversion gain mode.
    #[prost(enumeration = "gain_mode::GainModeType", tag = "1")]
    pub gain_mode: i32,
}
/// Nested message and enum types in `GainMode`.
pub mod gain_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GainModeType {
        /// * The gain mode is auto.
        Auto = 0,
        /// * The gain mode is low gain.
        LowGain = 1,
        /// * The gain mode is high gain.
        HighGain = 2,
    }
    impl GainModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Auto => "GAIN_MODE_TYPE_AUTO",
                Self::LowGain => "GAIN_MODE_TYPE_LOW_GAIN",
                Self::HighGain => "GAIN_MODE_TYPE_HIGH_GAIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GAIN_MODE_TYPE_AUTO" => Some(Self::Auto),
                "GAIN_MODE_TYPE_LOW_GAIN" => Some(Self::LowGain),
                "GAIN_MODE_TYPE_HIGH_GAIN" => Some(Self::HighGain),
                _ => None,
            }
        }
    }
}
/// *
/// It will be filled only when the video format is raw.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct BaselineExposure {
    /// * The amount in EV units to move the zero point for exposure
    /// compensation
    #[prost(float, tag = "1")]
    pub baseline_exposure: f32,
}
/// *
/// The quaternion provides a convenient mathematical notation for representing spatial orientations and rotations of
/// elements in three dimensional space. It can be converted to the Euler angle.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Quaternion {
    /// * The w value of quaternion.
    #[prost(float, tag = "1")]
    pub quaternion_w: f32,
    /// * The x value of quaternion.
    #[prost(float, tag = "2")]
    pub quaternion_x: f32,
    /// * The y value of quaternion.
    #[prost(float, tag = "3")]
    pub quaternion_y: f32,
    /// * The z value of quaternion.
    #[prost(float, tag = "4")]
    pub quaternion_z: f32,
}
/// *
/// The velocity of the device on the XYZ.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Velocity {
    /// * The velocity value on the X-axis. Unit: meter/second.
    #[prost(float, tag = "1")]
    pub velocity_x: f32,
    /// * The velocity value on the Y-axis. Unit: meter/second.
    #[prost(float, tag = "2")]
    pub velocity_y: f32,
    /// * The velocity value on the Z-axis. Unit: meter/second.
    #[prost(float, tag = "3")]
    pub velocity_z: f32,
}
/// *
/// The position of the device on the XYZ. The definition of origins may be different when this message is included in
/// different device, so refer to the specific product proto file for more details.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Position {
    /// * The position value on the X-axis. Unit: meter.
    #[prost(float, tag = "1")]
    pub position_x: f32,
    /// * The position value on the Y-axis. Unit: meter.
    #[prost(float, tag = "2")]
    pub position_y: f32,
    /// * The position value on the Z-axis. Unit: meter.
    #[prost(float, tag = "3")]
    pub position_z: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AbsoluteAltitude {
    /// * The absolute altitude of this device. It may come from the
    /// visual odometer. Unit: meter.
    #[prost(float, tag = "1")]
    pub absolute_altitude_m: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct RelativeAltitude {
    /// * The relative altitude of this device. It may come from the
    /// visual odometer. Unit: millimeter.
    #[prost(float, tag = "1")]
    pub relative_altitude_mm: f32,
    /// * The flag to indicate whether the relative altitude value is
    /// valid.
    #[prost(bool, tag = "2")]
    pub is_relative_altitude_valid: bool,
}
/// *
/// Represents the relative distance.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RelativeDistance {
    /// * The relative distance between two points. Unit: millimeter
    #[prost(int32, tag = "1")]
    pub relative_distance: i32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GimbalInstallPosition {
    /// * The install position of the gimbal which means the gimbal
    /// can be installed reversed or normally.
    #[prost(
        enumeration = "gimbal_install_position::GimbalInstallPositionType",
        tag = "1"
    )]
    pub gimbal_install_position: i32,
}
/// Nested message and enum types in `GimbalInstallPosition`.
pub mod gimbal_install_position {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GimbalInstallPositionType {
        /// * The install position of gimbal is normal.
        Normal = 0,
        /// * The install position of gimbal is reversed.
        Reverse = 1,
    }
    impl GimbalInstallPositionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Normal => "GIMBAL_INSTALL_POSITION_TYPE_NORMAL",
                Self::Reverse => "GIMBAL_INSTALL_POSITION_TYPE_REVERSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GIMBAL_INSTALL_POSITION_TYPE_NORMAL" => Some(Self::Normal),
                "GIMBAL_INSTALL_POSITION_TYPE_REVERSE" => Some(Self::Reverse),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GimbalMode {
    /// * The user-specified gimbal mode.
    #[prost(enumeration = "gimbal_mode::GimbalModeType", tag = "1")]
    pub gimbal_mode: i32,
}
/// Nested message and enum types in `GimbalMode`.
pub mod gimbal_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GimbalModeType {
        /// * The gimbal mode is off.
        GimbalModeOff = 0,
        /// * The gimbal mode is lock (or called cam_free).
        GimbalModeLock = 1,
        /// * The gimbal mode is follow. If the product supports to set
        /// pan/tilt/roll follow mode separately, refer to the message
        /// GimbalModeFollowSubStatus for more details.
        GimbalModeFollow = 2,
    }
    impl GimbalModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GimbalModeOff => "GIMBAL_MODE_OFF",
                Self::GimbalModeLock => "GIMBAL_MODE_LOCK",
                Self::GimbalModeFollow => "GIMBAL_MODE_FOLLOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GIMBAL_MODE_OFF" => Some(Self::GimbalModeOff),
                "GIMBAL_MODE_LOCK" => Some(Self::GimbalModeLock),
                "GIMBAL_MODE_FOLLOW" => Some(Self::GimbalModeFollow),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GimbalModeFollowSubStatus {
    /// * The flag to indicate whether the pan follow is on.
    #[prost(bool, tag = "1")]
    pub pan_follow: bool,
    /// * The flag to indicate whether the tilt follow is on.
    #[prost(bool, tag = "2")]
    pub tilt_follow: bool,
    /// * The flag to indicate whether the roll follow is on.
    #[prost(bool, tag = "3")]
    pub roll_follow: bool,
}
/// *
/// The Euler angles of gimbal relative to the NED (North, East, Down) coordinate system. Rotation sequence of the Euler
/// angle is ZXY (yaw, roll, pitch), intrinsic. For upward gimbal, the Euler angles translate from the real quaternion
/// of gimbal after rotate 180 degree around the X axis of moving body.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EulerAngle {
    /// * The Euler angles of Pitch. Unit: deci-degree.
    #[prost(int32, tag = "1")]
    pub pitch_decidegree: i32,
    /// * The Euler angles of Roll. Unit: deci-degree.
    #[prost(int32, tag = "2")]
    pub roll_decidegree: i32,
    /// * The Euler angles of Yaw. Unit: deci-degree.
    #[prost(int32, tag = "3")]
    pub yaw_decidegree: i32,
}
/// *
/// Represents the positioning coordinates expressed in latitude and longitude.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositionCoord {
    /// * The unit of positioning coordinates.
    #[prost(enumeration = "position_coord::PositionCoordUnit", tag = "1")]
    pub position_coord_unit: i32,
    /// * The latitude, WGS-84 coordinate system.
    #[prost(double, tag = "2")]
    pub latitude: f64,
    /// * The longitude, WGS-84 coordinate system.
    #[prost(double, tag = "3")]
    pub longitude: f64,
}
/// Nested message and enum types in `PositionCoord`.
pub mod position_coord {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PositionCoordUnit {
        /// * The unit of positioning coordinates is radian.
        UnitRad = 0,
        /// * The unit of positioning coordinates is degree.
        UnitDeg = 1,
    }
    impl PositionCoordUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnitRad => "UNIT_RAD",
                Self::UnitDeg => "UNIT_DEG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNIT_RAD" => Some(Self::UnitRad),
                "UNIT_DEG" => Some(Self::UnitDeg),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the time of GPS.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct GpsTime {
    /// * The GPS time,format: YYYY-MM-DD HH-MM-SS.
    #[prost(string, tag = "1")]
    pub time: ::prost::alloc::string::String,
}
/// *
/// Represents the basic information for GPS.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct GpsBasic {
    /// * The GPS latitude and longitude coordinates.
    #[prost(message, optional, tag = "1")]
    pub gps_coordinates: ::core::option::Option<PositionCoord>,
    /// * The GPS altitude, unit: mm, refer to gps_altitude_type for
    /// details.
    #[prost(int32, tag = "2")]
    pub gps_altitude_mm: i32,
    /// * The GPS status.
    #[prost(enumeration = "gps_basic::GpsStatus", tag = "3")]
    pub gps_status: i32,
    /// * The GPS altitude type.
    #[prost(enumeration = "gps_basic::GpsAltType", tag = "4")]
    pub gps_altitude_type: i32,
    /// * The GPS time valid flag.
    #[prost(bool, tag = "5")]
    pub has_gps_time: bool,
    /// * The GPS time
    #[prost(message, optional, tag = "6")]
    pub gps_time: ::core::option::Option<GpsTime>,
}
/// Nested message and enum types in `GpsBasic`.
pub mod gps_basic {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GpsStatus {
        /// * The GPS status is normal.
        GpsNormal = 0,
        /// * The GPS status is invalid.
        GpsInvalid = 1,
        /// * The GPS status is RTK.
        GpsRtk = 2,
    }
    impl GpsStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::GpsNormal => "GPS_NORMAL",
                Self::GpsInvalid => "GPS_INVALID",
                Self::GpsRtk => "GPS_RTK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GPS_NORMAL" => Some(Self::GpsNormal),
                "GPS_INVALID" => Some(Self::GpsInvalid),
                "GPS_RTK" => Some(Self::GpsRtk),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GpsAltType {
        /// * The altitude is provided by barometer which is not
        /// ellipsoidal height.
        PressureAltitude = 0,
        /// * Fuse GPS and barometer height, which based on ellipsoidal
        /// coordinate.
        GpsFusionAltitude = 1,
        /// * The altitude is ellipsoidal height (WGS-84) provided by
        /// RTK.
        RtkAltitude = 2,
    }
    impl GpsAltType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::PressureAltitude => "PRESSURE_ALTITUDE",
                Self::GpsFusionAltitude => "GPS_FUSION_ALTITUDE",
                Self::RtkAltitude => "RTK_ALTITUDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PRESSURE_ALTITUDE" => Some(Self::PressureAltitude),
                "GPS_FUSION_ALTITUDE" => Some(Self::GpsFusionAltitude),
                "RTK_ALTITUDE" => Some(Self::RtkAltitude),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the accelerometer of IMU.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Accelerometer {
    /// * The accelerometer in X direction, unit: degree.
    #[prost(float, tag = "2")]
    pub accelerometer_x: f32,
    /// * The accelerometer in Y direction, unit: degree.
    #[prost(float, tag = "3")]
    pub accelerometer_y: f32,
    /// * The accelerometer in Z direction, unit: degree.
    #[prost(float, tag = "4")]
    pub accelerometer_z: f32,
}
/// *
/// Represents the gyroscope of IMU.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Gyroscope {
    /// * The timestamp of each frame, unit: nano-seconds.
    #[prost(uint64, tag = "1")]
    pub msg_timestamp: u64,
    /// * The gyroscope in X direction, unit: 0.1 degree.
    #[prost(float, tag = "2")]
    pub gyroscope_x: f32,
    /// * The gyroscope in Y direction, unit: 0.1 degree.
    #[prost(float, tag = "3")]
    pub gyroscope_y: f32,
    /// * The gyroscope in Z direction, unit: 0.1 degree.
    #[prost(float, tag = "4")]
    pub gyroscope_z: f32,
}
/// *
/// Represents the status of laser ranging finder.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LaserStatus {
    #[prost(enumeration = "laser_status::LaserStatusType", tag = "1")]
    pub laser_status: i32,
}
/// Nested message and enum types in `LaserStatus`.
pub mod laser_status {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LaserStatusType {
        /// * The laser ranging finder works fine.
        LaserNormal = 0,
        /// * The target distance is less than minimum range of finder.
        LaserTooClose = 1,
        /// * The target distance is larger than maximum range of finder.
        LaserTooFar = 2,
        /// * The laser module is closed.
        LaserClosed = 3,
        /// * The target distance is out of range, maybe too close or too far.
        LaserOutOfRange = 4,
    }
    impl LaserStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::LaserNormal => "LASER_NORMAL",
                Self::LaserTooClose => "LASER_TOO_CLOSE",
                Self::LaserTooFar => "LASER_TOO_FAR",
                Self::LaserClosed => "LASER_CLOSED",
                Self::LaserOutOfRange => "LASER_OUT_OF_RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LASER_NORMAL" => Some(Self::LaserNormal),
                "LASER_TOO_CLOSE" => Some(Self::LaserTooClose),
                "LASER_TOO_FAR" => Some(Self::LaserTooFar),
                "LASER_CLOSED" => Some(Self::LaserClosed),
                "LASER_OUT_OF_RANGE" => Some(Self::LaserOutOfRange),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the raw sensor data of laser ranging finder.
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LaserRawData {
    /// * unit: millimeter
    #[prost(uint32, repeated, tag = "1")]
    pub distance: ::prost::alloc::vec::Vec<u32>,
    /// * The signal intensity, range: 0~255.
    #[prost(uint32, repeated, tag = "2")]
    pub intensity: ::prost::alloc::vec::Vec<u32>,
}
/// *
/// Represents the status of ranging function.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RangingStatus {
    #[prost(enumeration = "ranging_status::RangingStatusType", tag = "1")]
    pub ranging_status: i32,
}
/// Nested message and enum types in `RangingStatus`.
pub mod ranging_status {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RangingStatusType {
        /// * The ranging function is off.
        RangingOff = 0,
        /// * The ranging function is on.
        RangingOn = 1,
    }
    impl RangingStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RangingOff => "RANGING_OFF",
                Self::RangingOn => "RANGING_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RANGING_OFF" => Some(Self::RangingOff),
                "RANGING_ON" => Some(Self::RangingOn),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the target offset in screen.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ScreenOffset {
    /// * The target offset on horizontal direction of screen in permillage.
    #[prost(uint32, tag = "1")]
    pub screen_offset_x: u32,
    /// * The target offset on vertical direction of screen in permillage.
    #[prost(uint32, tag = "2")]
    pub screen_offset_y: u32,
}
/// *
/// Represents the scene mode of infrared camera.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfraredSceneMode {
    /// * The scene mode of infrared camera.
    #[prost(enumeration = "infrared_scene_mode::InfraredSceneModeType", tag = "1")]
    pub infrared_scene_mode: i32,
    /// * The DDE (digital detail enhance) value in percent, which is valid only in manual mode.
    #[prost(uint32, tag = "2")]
    pub infrared_dde_percent: u32,
    /// * The contrast value in percent, which is valid only in manual mode.
    #[prost(uint32, tag = "3")]
    pub infrared_contrast_percent: u32,
    /// * The brightness value in percent, which is valid only in manual mode.
    #[prost(uint32, tag = "4")]
    pub infrared_brightness_percent: u32,
}
/// Nested message and enum types in `InfraredSceneMode`.
pub mod infrared_scene_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InfraredSceneModeType {
        /// * The scene mode is manual. The dde, contrast and brightness are valid only in manual mode
        SceneModeManual = 0,
        /// * The scene mode is common.
        SceneModeCommon = 1,
        /// * The scene mode is inspection.
        SceneModeInspection = 2,
    }
    impl InfraredSceneModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::SceneModeManual => "SCENE_MODE_MANUAL",
                Self::SceneModeCommon => "SCENE_MODE_COMMON",
                Self::SceneModeInspection => "SCENE_MODE_INSPECTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SCENE_MODE_MANUAL" => Some(Self::SceneModeManual),
                "SCENE_MODE_COMMON" => Some(Self::SceneModeCommon),
                "SCENE_MODE_INSPECTION" => Some(Self::SceneModeInspection),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the pseudo color of infrared camera.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfraredPseudoColor {
    /// * The infrared pseudo color.
    #[prost(enumeration = "infrared_pseudo_color::InfraredPseudoColorType", tag = "1")]
    pub infrared_pseudo_color: i32,
}
/// Nested message and enum types in `InfraredPseudoColor`.
pub mod infrared_pseudo_color {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InfraredPseudoColorType {
        /// * The infrared pseudo color is whitehot.
        InfraredPseudoColorWhitehot = 0,
        /// * The infrared pseudo color is lava.
        InfraredPseudoColorLava = 1,
        /// * The infrared pseudo color is iron red.
        InfraredPseudoColorIronRed = 2,
        /// * The infrared pseudo color is hotiron.
        InfraredPseudoColorHotiron = 3,
        /// * The infrared pseudo color is medicine.
        InfraredPseudoColorMedicine = 4,
        /// * The infrared pseudo color is northpole.
        InfraredPseudoColorNorthpole = 5,
        /// * The infrared pseudo color is rainbow1.
        InfraredPseudoColorRainbow1 = 6,
        /// * The infrared pseudo color is rainbow2.
        InfraredPseudoColorRainbow2 = 7,
        /// * The infrared pseudo color is tracered.
        InfraredPseudoColorTracered = 8,
        /// * The infrared pseudo color is blackhot.
        InfraredPseudoColorBlackhot = 9,
    }
    impl InfraredPseudoColorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InfraredPseudoColorWhitehot => "INFRARED_PSEUDO_COLOR_WHITEHOT",
                Self::InfraredPseudoColorLava => "INFRARED_PSEUDO_COLOR_LAVA",
                Self::InfraredPseudoColorIronRed => "INFRARED_PSEUDO_COLOR_IRON_RED",
                Self::InfraredPseudoColorHotiron => "INFRARED_PSEUDO_COLOR_HOTIRON",
                Self::InfraredPseudoColorMedicine => "INFRARED_PSEUDO_COLOR_MEDICINE",
                Self::InfraredPseudoColorNorthpole => "INFRARED_PSEUDO_COLOR_NORTHPOLE",
                Self::InfraredPseudoColorRainbow1 => "INFRARED_PSEUDO_COLOR_RAINBOW1",
                Self::InfraredPseudoColorRainbow2 => "INFRARED_PSEUDO_COLOR_RAINBOW2",
                Self::InfraredPseudoColorTracered => "INFRARED_PSEUDO_COLOR_TRACERED",
                Self::InfraredPseudoColorBlackhot => "INFRARED_PSEUDO_COLOR_BLACKHOT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INFRARED_PSEUDO_COLOR_WHITEHOT" => {
                    Some(Self::InfraredPseudoColorWhitehot)
                }
                "INFRARED_PSEUDO_COLOR_LAVA" => Some(Self::InfraredPseudoColorLava),
                "INFRARED_PSEUDO_COLOR_IRON_RED" => {
                    Some(Self::InfraredPseudoColorIronRed)
                }
                "INFRARED_PSEUDO_COLOR_HOTIRON" => Some(Self::InfraredPseudoColorHotiron),
                "INFRARED_PSEUDO_COLOR_MEDICINE" => {
                    Some(Self::InfraredPseudoColorMedicine)
                }
                "INFRARED_PSEUDO_COLOR_NORTHPOLE" => {
                    Some(Self::InfraredPseudoColorNorthpole)
                }
                "INFRARED_PSEUDO_COLOR_RAINBOW1" => {
                    Some(Self::InfraredPseudoColorRainbow1)
                }
                "INFRARED_PSEUDO_COLOR_RAINBOW2" => {
                    Some(Self::InfraredPseudoColorRainbow2)
                }
                "INFRARED_PSEUDO_COLOR_TRACERED" => {
                    Some(Self::InfraredPseudoColorTracered)
                }
                "INFRARED_PSEUDO_COLOR_BLACKHOT" => {
                    Some(Self::InfraredPseudoColorBlackhot)
                }
                _ => None,
            }
        }
    }
}
/// *
/// Represents the isotherm of infrared camera.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfraredIsotherm {
    /// * The infrared isotherm mode.
    #[prost(enumeration = "infrared_isotherm::InfraredIsothermModeType", tag = "1")]
    pub infrared_isotherm_mode: i32,
    /// * The high threshold of infrared isotherm.
    #[prost(int32, tag = "2")]
    pub infrared_isotherm_high_threshold: i32,
    /// * The low threshold of infrared isotherm.
    #[prost(int32, tag = "3")]
    pub infrared_isotherm_low_threshold: i32,
}
/// Nested message and enum types in `InfraredIsotherm`.
pub mod infrared_isotherm {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InfraredIsothermModeType {
        /// * The infrared isotherm mode is off.
        InfraredIsothermModeOff = 0,
        /// * The infrared isotherm mode is on.
        InfraredIsothermModeOn = 1,
    }
    impl InfraredIsothermModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InfraredIsothermModeOff => "INFRARED_ISOTHERM_MODE_OFF",
                Self::InfraredIsothermModeOn => "INFRARED_ISOTHERM_MODE_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INFRARED_ISOTHERM_MODE_OFF" => Some(Self::InfraredIsothermModeOff),
                "INFRARED_ISOTHERM_MODE_ON" => Some(Self::InfraredIsothermModeOn),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the gain mode of infrared camera.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InfraredGainMode {
    /// * The user-specified gain mode of infrared camera.
    #[prost(enumeration = "infrared_gain_mode::InfraredGainModeType", tag = "1")]
    pub infrared_gain_mode: i32,
}
/// Nested message and enum types in `InfraredGainMode`.
pub mod infrared_gain_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InfraredGainModeType {
        /// * high gain mode which has narrow temperature measurement range but high precision.
        InfraredGainModeHigh = 0,
        /// * low gain mode which has wide temperature measurement range but low precision.
        InfraredGainModeLow = 1,
    }
    impl InfraredGainModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::InfraredGainModeHigh => "INFRARED_GAIN_MODE_HIGH",
                Self::InfraredGainModeLow => "INFRARED_GAIN_MODE_LOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "INFRARED_GAIN_MODE_HIGH" => Some(Self::InfraredGainModeHigh),
                "INFRARED_GAIN_MODE_LOW" => Some(Self::InfraredGainModeLow),
                _ => None,
            }
        }
    }
}
/// *
/// Represents the bias of exposure value.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExposureValue {
    #[prost(float, tag = "1")]
    pub exposure_value: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ColorTempAtmosphere {
    #[prost(uint32, tag = "1")]
    pub color_temp_atmosphere: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SensorTemperature {
    /// * uint: celsius degree.
    #[prost(float, tag = "1")]
    pub sensor_temperature: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SensorActiveSize {
    /// * The physical width for current sensor mode. uint: um
    #[prost(uint32, tag = "1")]
    pub sensor_active_physical_width_um: u32,
    /// * The physical height for current sensor mode. uint: um
    #[prost(uint32, tag = "2")]
    pub sensor_active_physical_height_um: u32,
}
/// Attitude of a specific device
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct DeviceAttitude {
    /// timestamp of the first sample in the attidue array.
    #[prost(uint32, tag = "1")]
    pub timestamp: u32,
    /// sensor vsync signal timestamp of first sample.
    #[prost(uint32, tag = "2")]
    pub vsync: u32,
    /// array containing all fusioned quaternions belong to certain vsync cnt, like 200/fps
    #[prost(message, repeated, tag = "3")]
    pub attitude: ::prost::alloc::vec::Vec<Quaternion>,
    /// time offset between first row of sensor exposure and first sample of device
    #[prost(float, tag = "4")]
    pub offset: f32,
}
/// Multi of the attitude set for a specific device
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct DeviceMultiAttitude {
    #[prost(message, optional, tag = "1")]
    pub current_frame: ::core::option::Option<DeviceAttitude>,
    #[prost(message, optional, tag = "2")]
    pub prev_frame: ::core::option::Option<DeviceAttitude>,
    #[prost(message, optional, tag = "3")]
    pub next_frame: ::core::option::Option<DeviceAttitude>,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SensorShiftParam {
    #[prost(uint32, repeated, tag = "1")]
    pub sensor_shift_arr: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "2")]
    pub sensor_shift_arr_with_roll: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "3")]
    pub sensor_shift_arr_without_roll: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "4")]
    pub sensor_shift_arr_only_yaw: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "5")]
    pub sensor_shift_ctrl_type: u32,
}
/// *
/// Represents the heading deviation between ground and navi.
/// Unit in 0.1 degree.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FaiDegree {
    #[prost(int32, tag = "1")]
    pub fai_g_deg: i32,
}
/// *
/// One-click fancy flight mode information for LightCut APP.
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FancyMode {
    /// * Timestamp of fancy flight mode in ms.
    #[prost(uint32, tag = "1")]
    pub timestamp: u32,
    /// * The type of fancy flight mode triggered by the user.
    #[prost(enumeration = "fancy_mode::FancyModeType", tag = "2")]
    pub fancy_mode_type: i32,
    /// * The actual number of times fancy flight is triggered.
    #[prost(uint32, tag = "3")]
    pub fancy_mode_act_cnt: u32,
}
/// Nested message and enum types in `FancyMode`.
pub mod fancy_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FancyModeType {
        FancyModeNull = 0,
        FancyModeTurnAroundRight = 1,
        FancyModeTurnAroundLeft = 2,
        FancyModeTurnOverRight = 3,
        FancyModeTurnOverLeft = 4,
        FancyModeTurnOverBack = 5,
        FancyModeTurnOverFront = 6,
    }
    impl FancyModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::FancyModeNull => "FANCY_MODE_NULL",
                Self::FancyModeTurnAroundRight => "FANCY_MODE_TURN_AROUND_RIGHT",
                Self::FancyModeTurnAroundLeft => "FANCY_MODE_TURN_AROUND_LEFT",
                Self::FancyModeTurnOverRight => "FANCY_MODE_TURN_OVER_RIGHT",
                Self::FancyModeTurnOverLeft => "FANCY_MODE_TURN_OVER_LEFT",
                Self::FancyModeTurnOverBack => "FANCY_MODE_TURN_OVER_BACK",
                Self::FancyModeTurnOverFront => "FANCY_MODE_TURN_OVER_FRONT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FANCY_MODE_NULL" => Some(Self::FancyModeNull),
                "FANCY_MODE_TURN_AROUND_RIGHT" => Some(Self::FancyModeTurnAroundRight),
                "FANCY_MODE_TURN_AROUND_LEFT" => Some(Self::FancyModeTurnAroundLeft),
                "FANCY_MODE_TURN_OVER_RIGHT" => Some(Self::FancyModeTurnOverRight),
                "FANCY_MODE_TURN_OVER_LEFT" => Some(Self::FancyModeTurnOverLeft),
                "FANCY_MODE_TURN_OVER_BACK" => Some(Self::FancyModeTurnOverBack),
                "FANCY_MODE_TURN_OVER_FRONT" => Some(Self::FancyModeTurnOverFront),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct LiveViewHfov {
    /// * liveview h_fov *
    #[prost(float, tag = "1")]
    pub lv_hfov: f32,
    /// * liveview h_fov_camera *
    #[prost(float, tag = "2")]
    pub lv_hfov_camera: f32,
    /// * view site of liveview *
    #[prost(float, tag = "3")]
    pub lv_view_site: f32,
    /// * the ratio of liveview frame width and height *
    #[prost(float, tag = "4")]
    pub lv_frame_ratio: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct GimbalAngleDeviation {
    #[prost(float, tag = "1")]
    pub x_deviation: f32,
    #[prost(float, tag = "2")]
    pub y_deviation: f32,
    #[prost(float, tag = "3")]
    pub z_deviation: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackingInfo {
    /// * smart eye mode for tk mode in video editor. bit 0:  is in tracking mode. bits 1-7: sub tracking mode, See DJI_TRACKING_MODE.
    #[prost(uint32, tag = "1")]
    pub tracking_mode: u32,
    /// * smart eye mode for tk mode in video editor. bit 0:  is in tracking mode. bits 1-7: sub tracking mode, See DJI_TRACKING_MODE.
    #[prost(uint32, tag = "2")]
    pub sub_tracking_mode: u32,
    #[prost(uint32, tag = "3")]
    pub id: u32,
    #[prost(uint32, tag = "4")]
    pub obj_class: u32,
    #[prost(float, tag = "5")]
    pub center_x: f32,
    #[prost(float, tag = "6")]
    pub center_y: f32,
    #[prost(float, tag = "7")]
    pub width: f32,
    #[prost(float, tag = "8")]
    pub height: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct UavToTargetPos {
    #[prost(uint64, tag = "1")]
    pub time_stamp_us: u64,
    /// * The aircraft's coordinates in the navigation frame.
    #[prost(float, repeated, tag = "2")]
    pub drone_coord_navi: ::prost::alloc::vec::Vec<f32>,
    /// * The aircraft's rotation relative to the navigation, quaternion wxyz.
    #[prost(message, optional, tag = "3")]
    pub q_drone2navi: ::core::option::Option<Quaternion>,
    /// * The yaw angle of the navigation frame relative to the ground frame, unit is radian, precision is 1 rad
    #[prost(float, tag = "4")]
    pub phi_g: f32,
    #[prost(enumeration = "uav_to_target_pos::TargetType", tag = "5")]
    pub target_type: i32,
    /// * The target's rotation relative to the navigation, quaternion wxyz.
    #[prost(message, optional, tag = "6")]
    pub q_target2navi: ::core::option::Option<Quaternion>,
    /// * Target 3D position validity flag. true or false
    #[prost(bool, tag = "7")]
    pub is_target_coord_valid: bool,
    /// * The target's coordinates in the navigation frame.
    #[prost(float, repeated, tag = "8")]
    pub target_coord_navi: ::prost::alloc::vec::Vec<f32>,
}
/// Nested message and enum types in `UavToTargetPos`.
pub mod uav_to_target_pos {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetType {
        Unknown = 0,
        Person = 1,
        Car = 2,
        Van = 3,
        Bike = 4,
        Animal = 5,
        Boat = 6,
        HumanFace = 7,
        HeadShoulder = 8,
        HumanBody = 9,
        HumanHead = 10,
        AnimalBody = 11,
        AnimalFace = 12,
        Beacon = 13,
        BeaconDisplay = 14,
    }
    impl TargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "TARGET_TYPE_UNKNOWN",
                Self::Person => "TARGET_TYPE_PERSON",
                Self::Car => "TARGET_TYPE_CAR",
                Self::Van => "TARGET_TYPE_VAN",
                Self::Bike => "TARGET_TYPE_BIKE",
                Self::Animal => "TARGET_TYPE_ANIMAL",
                Self::Boat => "TARGET_TYPE_BOAT",
                Self::HumanFace => "TARGET_TYPE_HUMAN_FACE",
                Self::HeadShoulder => "TARGET_TYPE_HEAD_SHOULDER",
                Self::HumanBody => "TARGET_TYPE_HUMAN_BODY",
                Self::HumanHead => "TARGET_TYPE_HUMAN_HEAD",
                Self::AnimalBody => "TARGET_TYPE_ANIMAL_BODY",
                Self::AnimalFace => "TARGET_TYPE_ANIMAL_FACE",
                Self::Beacon => "TARGET_TYPE_BEACON",
                Self::BeaconDisplay => "TARGET_TYPE_BEACON_DISPLAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_TYPE_UNKNOWN" => Some(Self::Unknown),
                "TARGET_TYPE_PERSON" => Some(Self::Person),
                "TARGET_TYPE_CAR" => Some(Self::Car),
                "TARGET_TYPE_VAN" => Some(Self::Van),
                "TARGET_TYPE_BIKE" => Some(Self::Bike),
                "TARGET_TYPE_ANIMAL" => Some(Self::Animal),
                "TARGET_TYPE_BOAT" => Some(Self::Boat),
                "TARGET_TYPE_HUMAN_FACE" => Some(Self::HumanFace),
                "TARGET_TYPE_HEAD_SHOULDER" => Some(Self::HeadShoulder),
                "TARGET_TYPE_HUMAN_BODY" => Some(Self::HumanBody),
                "TARGET_TYPE_HUMAN_HEAD" => Some(Self::HumanHead),
                "TARGET_TYPE_ANIMAL_BODY" => Some(Self::AnimalBody),
                "TARGET_TYPE_ANIMAL_FACE" => Some(Self::AnimalFace),
                "TARGET_TYPE_BEACON" => Some(Self::Beacon),
                "TARGET_TYPE_BEACON_DISPLAY" => Some(Self::BeaconDisplay),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SensorFrameReadOutTime {
    /// read out time per frame of a certain mode.
    #[prost(uint64, tag = "1")]
    pub readout_time: u64,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct LroValue {
    #[prost(uint32, tag = "1")]
    pub lro_value: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SensorRes {
    /// * The sensor width for current sensor mode.
    #[prost(uint32, tag = "1")]
    pub sensor_width: u32,
    /// * The sensor height for current sensor mode.
    #[prost(uint32, tag = "2")]
    pub sensor_height: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImuVsyncPos {
    /// Represents imu downsampling phase
    #[prost(uint32, tag = "1")]
    pub vsync_pos: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ItdValue {
    #[prost(int32, tag = "1")]
    pub itd_value: i32,
}
/// TODO: comment
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SensorReadDirection {
    #[prost(enumeration = "sensor_read_direction::SenorReadDirectionType", tag = "1")]
    pub direction: i32,
}
/// Nested message and enum types in `SensorReadDirection`.
pub mod sensor_read_direction {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SenorReadDirectionType {
        TopLeft = 0,
        TopRight = 1,
        BottomRight = 2,
        BottomLeft = 3,
        LeftTop = 4,
        RightTop = 5,
        RightBottom = 6,
        LeftBottom = 7,
    }
    impl SenorReadDirectionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TopLeft => "TOP_LEFT",
                Self::TopRight => "TOP_RIGHT",
                Self::BottomRight => "BOTTOM_RIGHT",
                Self::BottomLeft => "BOTTOM_LEFT",
                Self::LeftTop => "LEFT_TOP",
                Self::RightTop => "RIGHT_TOP",
                Self::RightBottom => "RIGHT_BOTTOM",
                Self::LeftBottom => "LEFT_BOTTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOP_LEFT" => Some(Self::TopLeft),
                "TOP_RIGHT" => Some(Self::TopRight),
                "BOTTOM_RIGHT" => Some(Self::BottomRight),
                "BOTTOM_LEFT" => Some(Self::BottomLeft),
                "LEFT_TOP" => Some(Self::LeftTop),
                "RIGHT_TOP" => Some(Self::RightTop),
                "RIGHT_BOTTOM" => Some(Self::RightBottom),
                "LEFT_BOTTOM" => Some(Self::LeftBottom),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct SensorFrameRate {
    #[prost(float, tag = "1")]
    pub sensor_frame_rate: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ImuSamplingRate {
    #[prost(uint32, tag = "1")]
    pub imu_sampling_rate: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct DigitalFocalLength {
    /// focal length output(fx) in both pinhole and fisheye in camera intrinsic matrix,
    /// lightCut app/gyroflow need to know this value to do c2w/w2c, in our model, fx equals to fy.
    #[prost(float, tag = "1")]
    pub focal_length: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct LensDistortionCoefficients {
    /// 1*4 array containing distortion coefficients (k1, k2, k3, k4) of an OpenCV fisheye model.
    #[prost(float, repeated, tag = "1")]
    pub coeffients: ::prost::alloc::vec::Vec<f32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EisStatus {
    #[prost(enumeration = "eis_status::EisStatusType", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `EisStatus`.
pub mod eis_status {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EisStatusType {
        EisOff = 0,
        EisRockSteady = 1,
        EisHorizonSteady = 2,
        EisHyper = 3,
        EisTradeoff = 4,
        EisHorizonBalancing = 5,
        EisDeepspace = 6,
        EisOffWithCrop = 7,
    }
    impl EisStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::EisOff => "EIS_OFF",
                Self::EisRockSteady => "EIS_ROCK_STEADY",
                Self::EisHorizonSteady => "EIS_HORIZON_STEADY",
                Self::EisHyper => "EIS_HYPER",
                Self::EisTradeoff => "EIS_TRADEOFF",
                Self::EisHorizonBalancing => "EIS_HORIZON_BALANCING",
                Self::EisDeepspace => "EIS_DEEPSPACE",
                Self::EisOffWithCrop => "EIS_OFF_WITH_CROP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EIS_OFF" => Some(Self::EisOff),
                "EIS_ROCK_STEADY" => Some(Self::EisRockSteady),
                "EIS_HORIZON_STEADY" => Some(Self::EisHorizonSteady),
                "EIS_HYPER" => Some(Self::EisHyper),
                "EIS_TRADEOFF" => Some(Self::EisTradeoff),
                "EIS_HORIZON_BALANCING" => Some(Self::EisHorizonBalancing),
                "EIS_DEEPSPACE" => Some(Self::EisDeepspace),
                "EIS_OFF_WITH_CROP" => Some(Self::EisOffWithCrop),
                _ => None,
            }
        }
    }
}
/// *
/// Represents current underwater confidence level
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CurrentUnderwaterConfidence {
    /// * To determine whether the device is currently underwater.
    #[prost(uint32, tag = "1")]
    pub current_underwater_confidence: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WayPointStatus {
    #[prost(enumeration = "way_point_status::WayPointStatusType", tag = "1")]
    pub status: i32,
}
/// Nested message and enum types in `WayPointStatus`.
pub mod way_point_status {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WayPointStatusType {
        WaypointOff = 0,
        WaypointOn = 1,
    }
    impl WayPointStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::WaypointOff => "WAYPOINT_OFF",
                Self::WaypointOn => "WAYPOINT_ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "WAYPOINT_OFF" => Some(Self::WaypointOff),
                "WAYPOINT_ON" => Some(Self::WaypointOn),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct FcmData {
    #[prost(fixed64, tag = "1")]
    pub timestamp: u64,
    #[prost(float, tag = "2")]
    pub center_x: f32,
    #[prost(float, tag = "3")]
    pub center_y: f32,
    #[prost(float, tag = "4")]
    pub min_x: f32,
    #[prost(float, tag = "5")]
    pub min_y: f32,
    #[prost(float, tag = "6")]
    pub max_x: f32,
    #[prost(float, tag = "7")]
    pub max_y: f32,
    /// drone orientations relative to tracking body
    #[prost(enumeration = "fcm_data::BodyRelativeDirection", tag = "8")]
    pub relative_direction: i32,
    /// drone orientations relative to moving destination
    #[prost(enumeration = "fcm_data::BodyRelativeDirection", tag = "9")]
    pub dest_direction: i32,
    #[prost(enumeration = "fcm_data::DroneMovement", tag = "10")]
    pub movement: i32,
    #[prost(float, tag = "11")]
    pub relative_horizontal_distance_m: f32,
    #[prost(float, tag = "12")]
    pub relative_height_m: f32,
    #[prost(float, tag = "13")]
    pub target_speed_mps: f32,
    #[prost(enumeration = "fcm_data::MovementExecState", tag = "14")]
    pub move_exec_state: i32,
    #[prost(enumeration = "fcm_data::ExitReason", tag = "15")]
    pub exit_reason: i32,
    #[prost(float, tag = "16")]
    pub score: f32,
}
/// Nested message and enum types in `FCMData`.
pub mod fcm_data {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DroneMovement {
        UnknownMove = 0,
        Clockwise = 1,
        CounterClockwise = 2,
        AutoChoice = 3,
    }
    impl DroneMovement {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::UnknownMove => "UNKNOWN_MOVE",
                Self::Clockwise => "CLOCKWISE",
                Self::CounterClockwise => "COUNTER_CLOCKWISE",
                Self::AutoChoice => "AUTO_CHOICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN_MOVE" => Some(Self::UnknownMove),
                "CLOCKWISE" => Some(Self::Clockwise),
                "COUNTER_CLOCKWISE" => Some(Self::CounterClockwise),
                "AUTO_CHOICE" => Some(Self::AutoChoice),
                _ => None,
            }
        }
    }
    /// geometrical orientations relative to a body
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BodyRelativeDirection {
        Behind = 0,
        BehindRight = 1,
        Right = 2,
        LeadRight = 3,
        Lead = 4,
        LeadLeft = 5,
        Left = 6,
        BehindLeft = 7,
        BehindOuter = 8,
        BehindRightOuter = 9,
        RightOuter = 10,
        LeadRightOuter = 11,
        LeadOuter = 12,
        LeadLeftOuter = 13,
        LeftOuter = 14,
        BehindLeftOuter = 15,
    }
    impl BodyRelativeDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Behind => "BEHIND",
                Self::BehindRight => "BEHIND_RIGHT",
                Self::Right => "RIGHT",
                Self::LeadRight => "LEAD_RIGHT",
                Self::Lead => "LEAD",
                Self::LeadLeft => "LEAD_LEFT",
                Self::Left => "LEFT",
                Self::BehindLeft => "BEHIND_LEFT",
                Self::BehindOuter => "BEHIND_OUTER",
                Self::BehindRightOuter => "BEHIND_RIGHT_OUTER",
                Self::RightOuter => "RIGHT_OUTER",
                Self::LeadRightOuter => "LEAD_RIGHT_OUTER",
                Self::LeadOuter => "LEAD_OUTER",
                Self::LeadLeftOuter => "LEAD_LEFT_OUTER",
                Self::LeftOuter => "LEFT_OUTER",
                Self::BehindLeftOuter => "BEHIND_LEFT_OUTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BEHIND" => Some(Self::Behind),
                "BEHIND_RIGHT" => Some(Self::BehindRight),
                "RIGHT" => Some(Self::Right),
                "LEAD_RIGHT" => Some(Self::LeadRight),
                "LEAD" => Some(Self::Lead),
                "LEAD_LEFT" => Some(Self::LeadLeft),
                "LEFT" => Some(Self::Left),
                "BEHIND_LEFT" => Some(Self::BehindLeft),
                "BEHIND_OUTER" => Some(Self::BehindOuter),
                "BEHIND_RIGHT_OUTER" => Some(Self::BehindRightOuter),
                "RIGHT_OUTER" => Some(Self::RightOuter),
                "LEAD_RIGHT_OUTER" => Some(Self::LeadRightOuter),
                "LEAD_OUTER" => Some(Self::LeadOuter),
                "LEAD_LEFT_OUTER" => Some(Self::LeadLeftOuter),
                "LEFT_OUTER" => Some(Self::LeftOuter),
                "BEHIND_LEFT_OUTER" => Some(Self::BehindLeftOuter),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MovementExecState {
        MoveNoCmd = 0,
        MoveReceivedStartCmd = 1,
        MoveExecuting = 2,
        MoveFinished = 3,
    }
    impl MovementExecState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::MoveNoCmd => "MOVE_NO_CMD",
                Self::MoveReceivedStartCmd => "MOVE_RECEIVED_START_CMD",
                Self::MoveExecuting => "MOVE_EXECUTING",
                Self::MoveFinished => "MOVE_FINISHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MOVE_NO_CMD" => Some(Self::MoveNoCmd),
                "MOVE_RECEIVED_START_CMD" => Some(Self::MoveReceivedStartCmd),
                "MOVE_EXECUTING" => Some(Self::MoveExecuting),
                "MOVE_FINISHED" => Some(Self::MoveFinished),
                _ => None,
            }
        }
    }
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExitReason {
        DjiFcmOk = 0,
        DjiFcmObstacleStuck = 1,
        DjiFcmAborted = 2,
    }
    impl ExitReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DjiFcmOk => "DJI_FCM_OK",
                Self::DjiFcmObstacleStuck => "DJI_FCM_OBSTACLE_STUCK",
                Self::DjiFcmAborted => "DJI_FCM_ABORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DJI_FCM_OK" => Some(Self::DjiFcmOk),
                "DJI_FCM_OBSTACLE_STUCK" => Some(Self::DjiFcmObstacleStuck),
                "DJI_FCM_ABORTED" => Some(Self::DjiFcmAborted),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RcMode {
    #[prost(enumeration = "rc_mode::RcModeEnum", tag = "1")]
    pub rc_mode: i32,
}
/// Nested message and enum types in `RC_Mode`.
pub mod rc_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RcModeEnum {
        DjiCommandModeManual = 0,
        DjiCommandModeAttiNormal = 3,
        DjiCommandModeGpsNormal = 7,
        DjiCommandModeGpsSport = 8,
        DjiCommandModeTripod = 12,
        DjiCommandModeFpv = 15,
    }
    impl RcModeEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::DjiCommandModeManual => "DJI_COMMAND_MODE_MANUAL",
                Self::DjiCommandModeAttiNormal => "DJI_COMMAND_MODE_ATTI_NORMAL",
                Self::DjiCommandModeGpsNormal => "DJI_COMMAND_MODE_GPS_NORMAL",
                Self::DjiCommandModeGpsSport => "DJI_COMMAND_MODE_GPS_SPORT",
                Self::DjiCommandModeTripod => "DJI_COMMAND_MODE_TRIPOD",
                Self::DjiCommandModeFpv => "DJI_COMMAND_MODE_FPV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DJI_COMMAND_MODE_MANUAL" => Some(Self::DjiCommandModeManual),
                "DJI_COMMAND_MODE_ATTI_NORMAL" => Some(Self::DjiCommandModeAttiNormal),
                "DJI_COMMAND_MODE_GPS_NORMAL" => Some(Self::DjiCommandModeGpsNormal),
                "DJI_COMMAND_MODE_GPS_SPORT" => Some(Self::DjiCommandModeGpsSport),
                "DJI_COMMAND_MODE_TRIPOD" => Some(Self::DjiCommandModeTripod),
                "DJI_COMMAND_MODE_FPV" => Some(Self::DjiCommandModeFpv),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BatteryInfo {
    #[prost(fixed32, tag = "1")]
    pub battery_percent: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BarrierDistance {
    #[prost(enumeration = "barrier_distance::TofState", tag = "1")]
    pub below_tof_state: i32,
    #[prost(sfixed32, tag = "2")]
    pub below_dist_cm: i32,
}
/// Nested message and enum types in `Barrier_Distance`.
pub mod barrier_distance {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TofState {
        NoReflection = 0,
        Reflected = 1,
    }
    impl TofState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::NoReflection => "TOF_STATE_NO_REFLECTION",
                Self::Reflected => "TOF_STATE_REFLECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOF_STATE_NO_REFLECTION" => Some(Self::NoReflection),
                "TOF_STATE_REFLECTED" => Some(Self::Reflected),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct RealFocalLength {
    /// * Because of the accuracy error which may comes from the lens
    /// craftsmanship, the real focal length may not be the same as
    /// the nominal focal length. Thus, this message will represent
    /// the real focal length which can reflect the focal length
    /// more realistically. In some cases such as visual effect,
    /// using this for calculation will get more accurate result.
    /// Its value will be described as rational type, so for
    /// example, when focal length is 35, its value will be
    /// \[35000, 1000\]. Unit: milli-meter.
    #[prost(int32, repeated, tag = "1")]
    pub real_focal_length: ::prost::alloc::vec::Vec<i32>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Barometer {
    /// * Is in the water.
    #[prost(bool, tag = "1")]
    pub is_in_water: bool,
    /// * The altitude from barometer, unit: decimeter.
    #[prost(int32, tag = "2")]
    pub altitude_dm: i32,
    /// * The pressure vale fro barometer, unit: hPa.
    #[prost(uint32, tag = "3")]
    pub atmospheric_hpa: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CameraControllerScene {
    #[prost(enumeration = "camera_controller_scene::CameraControllerScene", tag = "1")]
    pub camera_controller_scene: i32,
}
/// Nested message and enum types in `CameraControllerScene`.
pub mod camera_controller_scene {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CameraControllerScene {
        /// * The view seen using the standard remote controller, use as default.
        Standard = 0,
        /// * The view seen using goggles as the controller.
        Goggle = 1,
        /// * The view seen using app as the controller or without controller.
        Handheld = 2,
    }
    impl CameraControllerScene {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Standard => "CAMERA_CONTROLLER_SCENE_STANDARD",
                Self::Goggle => "CAMERA_CONTROLLER_SCENE_GOGGLE",
                Self::Handheld => "CAMERA_CONTROLLER_SCENE_HANDHELD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAMERA_CONTROLLER_SCENE_STANDARD" => Some(Self::Standard),
                "CAMERA_CONTROLLER_SCENE_GOGGLE" => Some(Self::Goggle),
                "CAMERA_CONTROLLER_SCENE_HANDHELD" => Some(Self::Handheld),
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EquivalentFocalLength {
    /// * The current 35mm equivalent hybrid focal length.
    /// Its value will be described as rational type, so for
    /// example, when focal length is 35, its value will be
    /// \[35000, 1000\]. Unit: milli-meter.
    #[prost(int32, repeated, tag = "1")]
    pub equivalent_focal_length: ::prost::alloc::vec::Vec<i32>,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct DewarpParams {
    #[prost(float, tag = "1")]
    pub fx: f32,
    #[prost(float, tag = "2")]
    pub fy: f32,
    #[prost(float, tag = "3")]
    pub cx: f32,
    #[prost(float, tag = "4")]
    pub cy: f32,
    #[prost(float, tag = "5")]
    pub k1: f32,
    #[prost(float, tag = "6")]
    pub k2: f32,
    #[prost(float, tag = "7")]
    pub k3: f32,
    #[prost(float, tag = "8")]
    pub k4: f32,
    #[prost(float, tag = "9")]
    pub xi: f32,
    #[prost(float, tag = "10")]
    pub width: f32,
    #[prost(float, tag = "11")]
    pub height: f32,
    #[prost(float, tag = "12")]
    pub yaw: f32,
    #[prost(float, tag = "13")]
    pub pitch: f32,
    #[prost(float, tag = "14")]
    pub roll: f32,
    #[prost(float, tag = "15")]
    pub k5: f32,
    #[prost(float, tag = "16")]
    pub k6: f32,
    #[prost(float, tag = "17")]
    pub k7: f32,
    #[prost(float, tag = "18")]
    pub k8: f32,
    #[prost(float, tag = "19")]
    pub k9: f32,
    #[prost(float, repeated, tag = "20")]
    pub p: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, tag = "21")]
    pub q: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, tag = "22")]
    pub occlusion_pt_x: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, repeated, tag = "23")]
    pub occlusion_pt_y: ::prost::alloc::vec::Vec<f32>,
    #[prost(float, tag = "24")]
    pub lens_model: f32,
    #[prost(float, tag = "25")]
    pub temperature: f32,
    /// * Extrinsic quaternion between the camera and the IMU.
    #[prost(message, optional, tag = "26")]
    pub cam_imu_extri_q: ::core::option::Option<Quaternion>,
    /// * tangential distortion coefficient
    #[prost(float, repeated, tag = "27")]
    pub tangent_coeff: ::prost::alloc::vec::Vec<f32>,
    /// * Extrinsic quaternion between camera modules.
    #[prost(message, optional, tag = "28")]
    pub cam_extri_q: ::core::option::Option<Quaternion>,
    #[prost(bool, tag = "29")]
    pub cam_imu_cali_enable: bool,
    #[prost(bool, tag = "30")]
    pub temp_compen_enable: bool,
    #[prost(float, tag = "31")]
    pub temp_compen_k: f32,
    #[prost(float, tag = "32")]
    pub gimbal_yaw_h1: f32,
    #[prost(float, tag = "33")]
    pub gimbal_yaw_h2: f32,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct PanoDewarpParams {
    #[prost(message, optional, tag = "1")]
    pub native_refine_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "2")]
    pub native_refine_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "3")]
    pub native_refine_far_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "4")]
    pub native_refine_far_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "5")]
    pub lens_guards_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "6")]
    pub lens_guards_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "7")]
    pub water_proof_above_water_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "8")]
    pub water_proof_above_water_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "9")]
    pub water_proof_under_water_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "10")]
    pub water_proof_under_water_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "11")]
    pub native_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "12")]
    pub native_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "13")]
    pub native_refine_far_07_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "14")]
    pub native_refine_far_07_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "15")]
    pub native_refine_far_09_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "16")]
    pub native_refine_far_09_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "17")]
    pub native_refine_far_11_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "18")]
    pub native_refine_far_11_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "19")]
    pub native_refine_far_12_5_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "20")]
    pub native_refine_far_12_5_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "21")]
    pub native_refine_far_14_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "22")]
    pub native_refine_far_14_master: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "23")]
    pub native_refine_far_16_slave: ::core::option::Option<DewarpParams>,
    #[prost(message, optional, tag = "24")]
    pub native_refine_far_16_master: ::core::option::Option<DewarpParams>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct AecAe {
    #[prost(float, tag = "1")]
    pub lv: f32,
    #[prost(float, tag = "2")]
    pub lux_idx: f32,
    #[prost(float, tag = "3")]
    pub short_linear_gain: f32,
    #[prost(float, tag = "4")]
    pub middle_linear_gain: f32,
    #[prost(float, tag = "5")]
    pub long_linear_gain: f32,
    #[prost(float, tag = "6")]
    pub adrc_gain: f32,
    #[prost(float, tag = "7")]
    pub dark_boost_gain: f32,
    #[prost(enumeration = "AeMode", tag = "8")]
    pub ae_mode: i32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct Coordinate {
    #[prost(float, tag = "1")]
    pub fx: f32,
    #[prost(float, tag = "2")]
    pub fy: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackResultBox {
    #[prost(message, optional, tag = "1")]
    pub vertex_top_left: ::core::option::Option<Coordinate>,
    #[prost(message, optional, tag = "2")]
    pub vertex_top_right: ::core::option::Option<Coordinate>,
    #[prost(message, optional, tag = "3")]
    pub vertex_bottom_left: ::core::option::Option<Coordinate>,
    #[prost(message, optional, tag = "4")]
    pub vertex_bottom_right: ::core::option::Option<Coordinate>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AimotDataVersion {
    /// * The protocal version of AI Multi-object Tracking.
    #[prost(fixed32, tag = "1")]
    pub ai_mot_version: u32,
}
#[derive(::serde::Serialize, Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ObjGroup2DBoxWithDistance {
    /// * Object ID.
    #[prost(fixed32, tag = "1")]
    pub obj_id: u32,
    /// * Object type. The max string length of it is 36 bytes (including ending symbol).
    #[prost(string, tag = "2")]
    pub obj_type: ::prost::alloc::string::String,
    /// * Object tracking state.
    #[prost(enumeration = "AiMotObjState", tag = "3")]
    pub obj_state: i32,
    /// * Object Center x coordinate. Unit: 1/10000*frame_width.
    #[prost(fixed32, tag = "4")]
    pub cx: u32,
    /// * Object Center y coordinate. Unit: 1/10000*frame_height.
    #[prost(fixed32, tag = "5")]
    pub cy: u32,
    /// * Object bounding box width. Unit: 1/10000*frame_width.
    #[prost(fixed32, tag = "6")]
    pub w: u32,
    /// * Object bounding box height. Unit: 1/10000*frame_height.
    #[prost(fixed32, tag = "7")]
    pub h: u32,
    /// * Object distance. Unit:mm
    #[prost(fixed32, tag = "8")]
    pub distance: u32,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct AimotData {
    /// * Indicates whether the AI object recognition uses a third-party model.
    #[prost(fixed32, tag = "1")]
    pub third_party_model: u32,
    /// * AI multi-object tracking detection model name. The max string length is 97 bytes (including ending symbol).
    #[prost(string, tag = "2")]
    pub model_name: ::prost::alloc::string::String,
    /// * The time stamp of AI multi-object tracking data, unit:ms.
    #[prost(fixed32, tag = "3")]
    pub ai_mot_timestamp_ms: u32,
    /// * The total number of AI multi-object detection results, which may exceed 128.
    #[prost(fixed32, tag = "4")]
    pub ai_mot_total_detected_obj_count: u32,
    /// * The AI multi-object stable detected object count, which is less than 128.
    #[prost(fixed32, tag = "5")]
    pub ai_mot_obj_count: u32,
    /// * The object bounding box data.
    #[prost(message, repeated, tag = "6")]
    pub ai_mot_obj_data: ::prost::alloc::vec::Vec<ObjGroup2DBoxWithDistance>,
}
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct EbikeGps {
    #[prost(message, optional, tag = "1")]
    pub gps_basic: ::core::option::Option<GpsBasic>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct EbikeAcc {
    #[prost(message, optional, tag = "1")]
    pub ebike_acc: ::core::option::Option<Accelerometer>,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct EbikeTiltAngle {
    /// float   | tilt (unit)
    #[prost(float, tag = "1")]
    pub tilt_angle: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikeMotorPower {
    /// motor power(unitW)
    #[prost(uint32, tag = "1")]
    pub power: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikePedalingPower {
    /// pedaling power(unitW)
    #[prost(uint32, tag = "1")]
    pub power: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikeCadence {
    /// cadence(unitRpm)
    #[prost(uint32, tag = "1")]
    pub cadence: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikeMotorTorque {
    /// motor torque(unitNm)
    #[prost(uint32, tag = "1")]
    pub torque: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikePedalingTorque {
    /// pedaling torque(unitNm)
    #[prost(uint32, tag = "1")]
    pub torque: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct EbikeSpeed {
    /// speed(unitkm/h)
    #[prost(float, tag = "1")]
    pub speed: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct EbikeMileage {
    /// mileage(unitkm)
    #[prost(float, tag = "1")]
    pub mileage: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, ::prost::Message)]
pub struct EbikeSlope {
    /// slope(unit)
    #[prost(float, tag = "1")]
    pub slope: f32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct HeartRate {
    /// heart beat(unitBpm)
    #[prost(uint32, tag = "1")]
    pub heartrate: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikePressure {
    /// air pressure(unithPa)
    #[prost(uint32, tag = "1")]
    pub pressure: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct EbikeCalories {
    /// calories (unitkcal)
    #[prost(uint32, tag = "1")]
    pub calories: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct YltmEnable {
    /// yltm enable
    #[prost(uint32, tag = "1")]
    pub enable: u32,
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ExtriLensMode {
    #[prost(enumeration = "extri_lens_mode::ExtriLensModeType", tag = "1")]
    pub mode: i32,
}
/// Nested message and enum types in `ExtriLensMode`.
pub mod extri_lens_mode {
   #[derive(::serde::Serialize,
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtriLensModeType {
        ExtriLensModeNativeRefine = 0,
        ExtriLensModeLensGuards = 1,
        ExtriLensModeWaterProofUnderWater = 2,
    }
    impl ExtriLensModeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::ExtriLensModeNativeRefine => "EXTRI_LENS_MODE_NATIVE_REFINE",
                Self::ExtriLensModeLensGuards => "EXTRI_LENS_MODE_LENS_GUARDS",
                Self::ExtriLensModeWaterProofUnderWater => {
                    "EXTRI_LENS_MODE_WATER_PROOF_UNDER_WATER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXTRI_LENS_MODE_NATIVE_REFINE" => Some(Self::ExtriLensModeNativeRefine),
                "EXTRI_LENS_MODE_LENS_GUARDS" => Some(Self::ExtriLensModeLensGuards),
                "EXTRI_LENS_MODE_WATER_PROOF_UNDER_WATER" => {
                    Some(Self::ExtriLensModeWaterProofUnderWater)
                }
                _ => None,
            }
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct AnyAspectRatioExport {
    #[prost(uint32, tag = "1")]
    pub support: u32,
    #[prost(uint32, tag = "2")]
    pub has_black_corner: u32,
}
#[derive(::serde::Serialize, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FcmLevel {
    SemiAutoFcm = 0,
    FullAutoFcm = 1,
}
impl FcmLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::SemiAutoFcm => "SEMI_AUTO_FCM",
            Self::FullAutoFcm => "FULL_AUTO_FCM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEMI_AUTO_FCM" => Some(Self::SemiAutoFcm),
            "FULL_AUTO_FCM" => Some(Self::FullAutoFcm),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AeMode {
    Off = 0,
    On = 1,
}
impl AeMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Off => "AE_MODE_OFF",
            Self::On => "AE_MODE_ON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AE_MODE_OFF" => Some(Self::Off),
            "AE_MODE_ON" => Some(Self::On),
            _ => None,
        }
    }
}
#[derive(::serde::Serialize, Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AiMotObjState {
    Invalid = 0,
    Tracked = 1,
}
impl AiMotObjState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Invalid => "AI_MOT_OBJ_STATE_INVALID",
            Self::Tracked => "AI_MOT_OBJ_STATE_TRACKED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AI_MOT_OBJ_STATE_INVALID" => Some(Self::Invalid),
            "AI_MOT_OBJ_STATE_TRACKED" => Some(Self::Tracked),
            _ => None,
        }
    }
}
/// *
/// Represents the proto entry when we do the encoding or decoding.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct ProductMeta {
    #[prost(message, optional, tag = "1")]
    pub clip_meta: ::core::option::Option<ClipMeta>,
    #[prost(message, optional, tag = "2")]
    pub stream_meta: ::core::option::Option<StreamMeta>,
    #[prost(message, optional, tag = "3")]
    pub frame_meta: ::core::option::Option<FrameMeta>,
}
/// *
/// Represents the metadata about video clip.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct ClipMeta {
    #[prost(message, optional, tag = "1")]
    pub clip_meta_header: ::core::option::Option<ClipMetaHeader>,
    #[prost(message, optional, tag = "2")]
    pub clip_streams_meta: ::core::option::Option<ClipStreamsMeta>,
    #[prost(message, optional, tag = "3")]
    pub distortion_coefficients: ::core::option::Option<LensDistortionCoefficients>,
    #[prost(message, optional, tag = "4")]
    pub sensor_readout_time: ::core::option::Option<SensorFrameReadOutTime>,
    #[prost(message, optional, tag = "5")]
    pub sensor_read_direction: ::core::option::Option<SensorReadDirection>,
    #[prost(message, optional, tag = "6")]
    pub digital_focal_length: ::core::option::Option<DigitalFocalLength>,
    #[prost(message, optional, tag = "7")]
    pub eis_status: ::core::option::Option<EisStatus>,
    #[prost(message, optional, tag = "8")]
    pub imu_sampling_rate: ::core::option::Option<ImuSamplingRate>,
    #[prost(message, optional, tag = "9")]
    pub sensor_fps: ::core::option::Option<SensorFrameRate>,
    #[prost(message, optional, tag = "10")]
    pub itd_value: ::core::option::Option<ItdValue>,
    #[prost(message, optional, tag = "11")]
    pub lro_value: ::core::option::Option<LroValue>,
    #[prost(message, optional, tag = "12")]
    pub sensor_res: ::core::option::Option<SensorRes>,
}
/// *
/// Represents the metadata about video stream.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct StreamMeta {
    #[prost(message, optional, tag = "1")]
    pub stream_meta_header: ::core::option::Option<StreamMetaHeader>,
    #[prost(message, optional, tag = "2")]
    pub camera_stream_meta: ::core::option::Option<StreamMetaOfCamera>,
    #[prost(message, optional, tag = "3")]
    pub video_stream_meta: ::core::option::Option<VideoStreamMeta>,
    #[prost(message, optional, tag = "4")]
    pub fov_type: ::core::option::Option<FovType>,
    #[prost(message, optional, tag = "5")]
    pub pano_dewarp_params: ::core::option::Option<PanoDewarpParams>,
}
/// *
/// Represents the stream metadata of camera device.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct StreamMetaOfCamera {
    #[prost(message, optional, tag = "1")]
    pub device_header: ::core::option::Option<MetaHeaderOfDevice>,
    #[prost(message, optional, tag = "2")]
    pub device_version: ::core::option::Option<DeviceVersion>,
    #[prost(message, optional, tag = "3")]
    pub device_sn: ::core::option::Option<DeviceSn>,
    #[prost(message, optional, tag = "4")]
    pub color_mode: ::core::option::Option<ColorMode>,
    #[prost(message, optional, tag = "5")]
    pub sharpness: ::core::option::Option<Sharpness>,
    #[prost(message, optional, tag = "6")]
    pub denoise: ::core::option::Option<NoiseReductionApplied>,
}
/// *
/// Represents the metadata about video frame.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct FrameMeta {
    #[prost(message, optional, tag = "1")]
    pub frame_meta_header: ::core::option::Option<FrameMetaHeader>,
    #[prost(message, optional, tag = "2")]
    pub camera_frame_meta: ::core::option::Option<FrameMetaOfCamera>,
    #[prost(message, optional, tag = "3")]
    pub imu_frame_meta: ::core::option::Option<FrameMetaOfImu>,
    #[prost(message, optional, tag = "4")]
    pub drone_frame_meta: ::core::option::Option<FrameMetaOfDrone>,
}
/// *
/// Represents the frame metadata of camera device.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct FrameMetaOfCamera {
    #[prost(message, optional, tag = "1")]
    pub camera_dev_header: ::core::option::Option<MetaHeaderOfDevice>,
    #[prost(message, optional, tag = "2")]
    pub exposure_index: ::core::option::Option<ExposureIndex>,
    #[prost(message, optional, tag = "3")]
    pub iso: ::core::option::Option<Iso>,
    #[prost(message, optional, tag = "4")]
    pub exposure_time: ::core::option::Option<ExposureTime>,
    #[prost(message, optional, tag = "5")]
    pub digital_zoom_ratio: ::core::option::Option<DigitalZoomRatio>,
    #[prost(message, optional, tag = "6")]
    pub white_balance_cct: ::core::option::Option<WhiteBalanceCct>,
    #[prost(message, optional, tag = "7")]
    pub orientation: ::core::option::Option<Orientation>,
    #[prost(message, optional, tag = "8")]
    pub exposure_value: ::core::option::Option<ExposureValue>,
    #[prost(message, optional, tag = "9")]
    pub color_temp_atmosphere: ::core::option::Option<ColorTempAtmosphere>,
    #[prost(message, optional, tag = "10")]
    pub focal_length: ::core::option::Option<FocalLength>,
    #[prost(message, optional, tag = "11")]
    pub absolute_altitude: ::core::option::Option<AbsoluteAltitude>,
    #[prost(message, optional, tag = "12")]
    pub sensor_temperature: ::core::option::Option<SensorTemperature>,
    #[prost(message, optional, tag = "13")]
    pub sensor_active_size: ::core::option::Option<SensorActiveSize>,
    #[prost(message, optional, tag = "14")]
    pub f_number: ::core::option::Option<FNumber>,
    #[prost(message, optional, tag = "15")]
    pub digital_focal_length: ::core::option::Option<DigitalFocalLength>,
    /// * The target or current quaternon about eis
    #[prost(message, optional, tag = "16")]
    pub sensor_shift_param: ::core::option::Option<SensorShiftParam>,
    /// * One-click fancy flight mode information for LightCut APP
    #[prost(message, optional, tag = "17")]
    pub fancy_mode: ::core::option::Option<FancyMode>,
    #[prost(message, optional, tag = "18")]
    pub liveview_hfov: ::core::option::Option<LiveViewHfov>,
}
/// *
/// Represents the frame metadata of drone device.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct FrameMetaOfDrone {
    #[prost(message, optional, tag = "1")]
    pub drone_dev_header: ::core::option::Option<MetaHeaderOfDevice>,
    /// * Represent the drone body velocity in NED coordinate system. unit: meter/second
    #[prost(message, optional, tag = "2")]
    pub velocity: ::core::option::Option<Velocity>,
    /// * Represent the drone body attitude in NED coordinate system. unit: 0.1 degree
    #[prost(message, optional, tag = "3")]
    pub attitude: ::core::option::Option<EulerAngle>,
    /// * Represent the drone gps basic information.
    #[prost(message, optional, tag = "4")]
    pub gps: ::core::option::Option<GpsBasic>,
    /// * Represent the drone body altitude relative to takeoff point. unit: millimeter
    #[prost(message, optional, tag = "5")]
    pub relative_altitude: ::core::option::Option<RelativeAltitude>,
    #[prost(message, optional, tag = "6")]
    pub battery: ::core::option::Option<BatteryInfo>,
    #[prost(message, optional, tag = "7")]
    pub rc_mode: ::core::option::Option<RcMode>,
    #[prost(message, optional, tag = "8")]
    pub barr_dist: ::core::option::Option<BarrierDistance>,
    #[prost(message, optional, tag = "9")]
    pub fai_degree: ::core::option::Option<FaiDegree>,
    #[prost(message, optional, tag = "10")]
    pub fcm_data: ::core::option::Option<FcmData>,
    #[prost(message, optional, tag = "11")]
    pub gimbal_angle_deviation: ::core::option::Option<GimbalAngleDeviation>,
    #[prost(message, optional, tag = "12")]
    pub filming_target_position: ::core::option::Option<UavToTargetPos>,
    #[prost(message, optional, tag = "13")]
    pub tracking_info: ::core::option::Option<TrackingInfo>,
}
/// *
/// Represents the frame metadata of IMU device.
#[derive(::serde::Serialize, Clone, PartialEq, ::prost::Message)]
pub struct FrameMetaOfImu {
    #[prost(message, optional, tag = "1")]
    pub imu_dev_header: ::core::option::Option<MetaHeaderOfDevice>,
    /// * cur/last/next frame. camera attitude samples within video frame interval. processed after motion estimation
    #[prost(message, optional, tag = "2")]
    pub imu_attitude_after_fusion: ::core::option::Option<DeviceMultiAttitude>,
    #[prost(message, optional, tag = "3")]
    pub imu_vsync_pos: ::core::option::Option<ImuVsyncPos>,
    /// * cur frame. camera attitude samples within video frame interval. processed after motion estimation
    #[prost(message, optional, tag = "4")]
    pub imu_single_attitude_after_fusion: ::core::option::Option<DeviceAttitude>,
}
